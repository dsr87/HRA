phpSecureSite 0.1.2 documentation

Erik Grinaker

   Copyright © 2002-2003 Erik Grinaker

   Permission is granted to copy, distribute and/or modify this
   document under the terms of the GNU Free Documentation
   License, Version 1.2 or any later version published by the
   Free Software Foundation; with no Invariant Sections, no
   Front-Cover Texts, and no Back-Cover Texts. A copy of the
   license is included in the section entitled "GNU Free
   Documentation License".
     _________________________________________________________

   Table of Contents
   Release Notes
   1. Introduction

        1.1. What is it?
        1.2. Overview
        1.3. Licence

   2. Installation

        2.1. Requirements
        2.2. Installing phpSecureSite

   3. Configuration

        3.1. Initial configuration
        3.2. Configuration options

              3.2.1. Core system
              3.2.2. Database options
              3.2.3. Authentication options
              3.2.4. Logging options
              3.2.5. Configuring normal modules

        3.3. Using a different config file

   4. Usage

        4.1. Introduction
        4.2. Accessing the database
        4.3. The cache system
        4.4. Using additional account data
        4.5. A simple example application

              4.5.1. Login form
              4.5.2. Login script
              4.5.3. Global-include
              4.5.4. Secret page
              4.5.5. Logout script

        4.6. Security considerations
        4.7. More examples

              4.7.1. Displaying login errors in the login form
              4.7.2. Redirect to login form if not logged in
              4.7.3. Case-insensitive usernames

   5. Administration

        5.1. Introduction
        5.2. Managing user accounts

              5.2.1. Adding users
              5.2.2. Deleting users
              5.2.3. Managing groups
              5.2.4. Group memberships

   6. Modules

        6.1. Database modules

              6.1.1. mssql (Microsoft SQL Server)
              6.1.2. mysql
              6.1.3. pgsql (PostgreSQL)

        6.2. Authentication modules

              6.2.1. database
              6.2.2. ldap
              6.2.3. mysql
              6.2.4. pgsql (PostgreSQL)

        6.3. Log modules

              6.3.1. database
              6.3.2. file
              6.3.3. syslog

        6.4. Normal modules

              6.4.1. acl (access control lists)
              6.4.2. bruteforce (bruteforce attack protection)
              6.4.3. cachecontrol (control cache policies using
                      http headers)

              6.4.4. hijack (session hijacking countermeasures)
              6.4.5. ipaccess (client ip access control)
              6.4.6. loginfaildelay (delays failed login
                      attempts)

              6.4.7. svars (session variables)
              6.4.8. timeout (session timeouts)
              6.4.9. usertrack (page request tracking)

   7. Tools

        7.1. dbclean (database cleanups)

   8. Module development

        8.1. Introduction
        8.2. Module registration
        8.3. Configuration options
        8.4. Storing temporary data
        8.5. The event system
        8.6. Handlers
        8.7. Using caches
        8.8. Logging and error reporting

   9. Reference

        9.1. Functions

              9.1.1. Authentication and account/group data
              9.1.2. Database
              9.1.3. Cache
              9.1.4. Event
              9.1.5. Logging
              9.1.6. Main control functions
              9.1.7. Miscellaneous
              9.1.8. Module
              9.1.9. Session
              9.1.10. acl module (access control list)
              9.1.11. svars module (session variables)

        9.2. Constants

              9.2.1. Module types
              9.2.2. Log classes
              9.2.3. Cache stores
              9.2.4. Miscellaneous

        9.3. Events

              9.3.1. System-related events
              9.3.2. Session creation, phpss_login()
              9.3.3. Session validation, phpss_validate()
              9.3.4. Session closing, phpss_logout()

        9.4. Handlers

              9.4.1. Authentication handlers
              9.4.2. Database handlers
              9.4.3. Log handlers

        9.5. Database structure

   A. Project information
   B. Related articles and documents
   C. GNU General Public Licence, version 2
   D. GNU Free Documentation License, version 1.2
     _________________________________________________________

Release Notes

   Version 0.1.2 is primarily a bugfix release. The most notable
   bug completely broke the database log module, but it is now
   working again. A few minor security issues have also been
   fixed. In addition, an LDAP authentication module has been
   added, and all the modules now set default configuration
   values which are used as fallbacks if the option is not set in
   the configuration files.
     _________________________________________________________

Chapter 1. Introduction

1.1. What is it?

   phpSecureSite is an authentication and session-handling system
   for PHP. It is primarily intended for use in closed
   web-applications, where a user is required to enter a username
   and password to enter the site. It is made to be fully
   integrated with the web-application, which means that you will
   have to code a frontend (such as login screens etc) for it
   yourself.

   Authentication is done with the widely used username and
   password scheme, where a user first identifies himself (the
   username) and then provides a secret known only to the user
   (the password) to prove that he is who is he claims to be.

   To understand what a session handling system is, we need to
   take a look at how the web-server sees the world. The HTTP
   protocol, which is the language that your computer and the
   web-server uses to communicate, is a so-called stateless
   protocol. What this means is that when the web-server gets a
   request for a page it simply returns that page, no questions
   asked. It does not know, nor does it care, which user a
   request comes from. A session handling system determines which
   user makes a request, so that the page returned to the client
   can be dynamically built for that user.

   The most basic use of phpSecureSite is obviously to protect
   access to an application or a set of web-pages, but you can
   also do alot more with it. It comes with a set of modules
   which provides functionality such as session variables (which
   lets you store a piece of data for a session, and retrieve
   that data in any page), access control lists (for setting
   which users/groups should be allowed access to a specific
   page) and much more.

   The only downside with phpSecureSite is that it stores all its
   data in a database. This means that each and every request
   will result in at least one lookup in the database, which is
   not good for performance. But to do everything phpSecureSite
   does there is really no other way to do this. If you just need
   a light-weight session-handling system, you may be better off
   with some other package.
     _________________________________________________________

1.2. Overview

   The system consists of a relatively stripped down core which
   just handles the basic session handling and provides
   miscellaneous infrastructure, and modules for just about
   everything else. The core system is made up of the main
   phpSecureSite file, phpss/phpss.php and function libraries
   under phpss/func/, while the modules are placed in the
   phpss/modules/ directory.

   phpSecureSite needs to store some data in order to keep track
   of everything that's going on. For this it uses an SQL
   database as a backend. The structure of this database can be
   found in the database/ directory.

   Modules are used for just about everything; database modules
   handles basic database communication so that you can use any
   database server you wish (as long as a database module is
   available for it), authentication modules handles
   authentication and account/group data lookups from various
   backends, log modules handle message logging to miscellaneous
   destinations such as the database or text-files, and normal
   modules take care of any extra functionality.

   The main mechanism for the session handling system is cookies.
   When a user logs in, a cookie, which is simply a piece of
   data, is stored in the client browser. This cookie contains a
   unique identifier for the session, called the session key,
   which is sent back to the web-server on every page request.
   phpSecureSite will then compare this session key against the
   data it has stored about the session, and allow or deny access
   accordingly.
     _________________________________________________________

1.3. Licence

   phpSecureSite is released under the GNU General Public
   Licence, version 2, and the documentation is licenced under
   the GNU Free Documentation License, version 1.2. The full text
   of the licences can be found in the appendices of this manual.
     _________________________________________________________

Chapter 2. Installation

2.1. Requirements

   phpSecureSites requirements are pretty flexible. You do need
   PHP version 4.3.0 or newer, but other than that you should be
   able to use pretty much any modern web-server and database
   server (as long as a database module for the database server
   is available).

   A recommended configuration would be an Apache web server with
   PHP compiled as a module (not CGI) and doing all client-server
   communication via SSL using mod_ssl. The database server
   should be either MySQL or PostgreSQL. All server software
   should run on a UNIX operating system, preferrably Linux, one
   of the BSDs or Sun Solaris.
     _________________________________________________________

2.2. Installing phpSecureSite

   Before installing phpSecureSite please make sure that your
   web-server and database server are functioning properly. You
   should also note that these instructions are for UNIX systems
   - for Windows systems you are pretty much on your own
   (although the process is roughly the same).

   Installing phpSecureSite is a rather straight-forward job. The
   first thing to do is to unpack the source archive and cd into
   the phpSecureSite archive directory. This is done with these
   commands:

$ tar -jxvf phpsecuresite-0.1.2.tar.bz2
$ cd phpsecuresite-0.1.2/

   (if your version of tar doesn't support bunzip'ing you can
   instead use a command such as bzip2 -c -d
   phpsecuresite-0.1.2.tar.bz2 | tar -xv to unpack the archive)

   Next you must create a database for phpSecureSite to use, and
   then import the database structure. This structure is
   available as SQL-queries in normal ASCII text-files under the
   database/ directory. There is a file for each supported
   database backend - use the one appropriate for your server.

   Before importing the database structure you should make sure a
   valid database account exists for phpSecureSite to use. See
   your database server's documentation for information on
   setting up an account. phpSecureSite needs to have permissions
   to run SELECT, INSERT, UPDATE and DELETE operations on all
   tables in the database.

   Here is an example on how to import the structure into a MySQL
   database server (for other database servers please refer to
   the server's official documentation) :

mysql> CREATE DATABASE phpss;
Query OK, 1 row affected (0.04 sec)

mysql> USE phpss;
Database changed
mysql> source database/mysql.sql;

   Next you need to place phpSecureSite itself somewhere. It is
   not recommended to place it under the web-servers document
   root (often /var/www/htdocs), as it can then be accessed and
   manipulated by anyone. You could, for example, place it under
   /opt/phpsecuresite/, but this is really up to you. For
   example:

$ mkdir /opt/phpsecuresite
$ cp -Rv * /opt/phpsecuresite

   That's it, phpSecureSite is now installed and ready for use.
   Now you need to configure it, take a look at the Configuration
   section for more information. You should also add an account
   to the database for testing - info on this is available in the
   Managing user accounts section.
     _________________________________________________________

Chapter 3. Configuration

3.1. Initial configuration

   When phpSecureSite has been installed, you need to configure
   it. You should read this entire chapter to get an idea of what
   you can do with phpSecureSite, but here is a quick guide for
   the impatient:

     * You need to set up a way for phpSecureSite to connect to
       your database server. Open config/database.php in a
       text-editor, set the name of the database module you would
       like to use in $phpss_cfg["phpss"]["database_module"] and
       then set connection information in the modules
       configuration later in the same file.
     * phpSecureSite also needs to know where to find account
       data. Settings for this is located in
       config/authentication.php. The default options will use
       the normal phpSecureSite database for account data, which
       usually is what you want. Note that by default,
       phpSecureSite expects passwords to be in md5 format, you
       can change this by changing the
       $phpss_cfg["phpss"]["auth_pwtype"] option.
     * If you want to use logging you must open the file
       config/logging.php and set
       $phpss_cfg["phpss"]["log_enable"] option to true. By
       default, log messages are stored in the phpSecureSite
       database.
     _________________________________________________________

3.2. Configuration options

3.2.1. Core system

   The core system is configured in config/phpss.php.
     _________________________________________________________

3.2.1.1. Error reporting

   These options are used to control the error reporting
   facilities, and can be very useful when debugging a problem.

   $phpss_cfg["phpss"]["error_handler"]
          You can specify your own error handling function here,
          in order to make the error messages better integrated
          with your site. Put the name of the function which will
          handle error messages here, but make sure it takes the
          error data as an argument. It should not abort script
          execution, as that would prevent phpSecureSite from
          logging the error.

   $phpss_cfg["phpss"]["error_extrainfo"]
          When this is enabled, error messages will be printed
          with extended information about the error, such as the
          location of the error and any extra information
          provided.

   $phpss_cfg["phpss"]["error_backtrace"]
          When enabled, errors will include a backtrace of the
          error call. This is very useful for tracking down
          exactly where the error occurs.

   Warning

   The error_extrainfo and error_backtrace options will reveal
   alot of information about how your system works. They should
   only be enabled when debugging a known problem, and be left
   off during normal operation.
     _________________________________________________________

3.2.1.2. Cache options

   The cache system is used to temporarily store data from the
   database in memory when it is looked up, so that later
   requests for the data won't result in another database lookup.
   This is usually a good thing, but you may want to disable it
   for various reasons.

   $phpss_cfg["phpss"]["cache"]
          Enables or disables the cache system.
     _________________________________________________________

3.2.1.3. Session cookie

   You can set a few parameters for the cookie phpSecureSite uses
   to identify sessions. Normally, the default settings should be
   just fine, but in certain environments they may need to be
   changed.

   $phpss_cfg["phpss"]["cookie_name"]
          The name of the cookie

   $phpss_cfg["phpss"]["cookie_path"]
          The server path under which the cookie is valid. Should
          be set to the url root of your application.

   $phpss_cfg["phpss"]["cookie_domain"]
          The domain for which the cookie is valid. Defaults to
          the server hostname. If you have several web-servers
          with phpSecureSite working against a shared database,
          authenticated users don't need to log in again to
          access resources on a different server if they are in
          the same domain.
     _________________________________________________________

3.2.2. Database options

   You need to tell phpSecureSite how to access the database
   server. This is done in the file config/database.php. First
   you must set which database module to use, and then configure
   the database module in the same file. The options for the
   various database modules are described in the Database modules
   section.

   Note

   All modules have a modulefile option. This is used internally
   in phpSecureSite to map the name of a module to a file, and
   should not be changed.

   $phpss_cfg["phpss"]["database_module"]
          The name of the database module to use.
     _________________________________________________________

3.2.3. Authentication options

   Authentication is configured in the file
   config/authentication.php. You must first define which
   authentication module to use, and then set options for the
   module in the same file. Information on config options for the
   various authentication modules is available in the
   Authentication modules section.

   Note

   Normally, you should use the database module, which will look
   up module information in the normal phpSecureSite database.
   The other modules are for authenticating against different
   databases, such as an existing e-mail account database.

   Note

   All modules have a modulefile option. This is used internally
   in phpSecureSite to map the name of a module to a file, and
   should not be changed.

   $phpss_cfg["phpss"]["auth_module"]
          The name of the authentication module to use.

   $phpss_cfg["phpss"]["auth_pwtype"]
          Defines the format passwords are stored with in the
          database. The password processing is done in the core
          system, which means that all these algorithms are
          available regardless of the authentication module which
          is used. Valid values are:

          + crypt : encrypted using the UNIX crypt() function.
            The algorithm is determined by the underlying system
            libraries.
          + md5 : hashed using the md5 algorithm
          + mysql : hashed using MySQLs PASSWORD() algorithm. It
            is not recommended to use it, as it uses a very
            insecure algorithm (even the MySQL manual says it
            should not be used). It is available for
            compatibility only.
          + plaintext : passwords are stored as-is
          + sha1 : hashed using the sha1 algorithm
     _________________________________________________________

3.2.4. Logging options

   The log system is configured in the config/logging.php file.
   Define which log module to use, and then configure the module
   in the same file. Descriptions of the various log module
   options can be found in the Log modules sectiond.

   $phpss_cfg["phpss"]["log_class"]
          Which log message classes to log. Log messages of equal
          or higher severity will be logged. Valid values are:

          + PHPSS_LOG_INFO : informational messages (user
            login/logout etc)
          + PHPSS_LOG_NOTICE : significant but normal messages
            (database cleanups etc)
          + PHPSS_LOG_WARNING : warnings (session hijack attempts
            etc)
          + PHPSS_LOG_ERROR : error messages (database connection
            failures etc)

   $phpss_cfg["phpss"]["log_enable"]
          Set to true to enable logging.

   $phpss_cfg["phpss"]["log_module"]
          The name of the log module to use.
     _________________________________________________________

3.2.5. Configuring normal modules

   Normal modules are configured in config/modules.php.

   All modules share two common options; enable and modulefile.
   enable defines if the module should be loaded and activated,
   or not - true if it should be loaded, and false if not.
   modulefile sets the full path to the module file, and normally
   shouldn't be changed.

   Descriptions of the modules and their options are found in the
   Normal modules section.
     _________________________________________________________

3.3. Using a different config file

   You may want to load a different config file than the default
   one, config/phpss.php. To do this, you can set the
   PHPSS_CONFIGFILE constant to contain the full path to the file
   phpSecureSite should load its configuration from. This
   constant must be set before you load phpSecureSite, like this:

// set config file to use
define("PHPSS_CONFIGFILE", "/etc/phpss.conf");

// load phpSecureSite
require("phpss/phpss.php");

   A configuration file is a normal php script, which is included
   like any other php file. This means that if you, for example,
   need to load options from several config files, you can use
   require() in you main config file to fetch data from other
   files.

   Specifying which configuration file to use can be useful, for
   example, if you use the same phpSecureSite installation for
   multiple web-sites.
     _________________________________________________________

Chapter 4. Usage

4.1. Introduction

   One of the goals of phpSecureSite is to make it fully
   integrated with the web-application, so that users won't
   notice that the authentication and session system isn't a part
   of your application. To achieve it you will need to write some
   code for it yourself, and this chapter will teach you how to
   do it, and show some of the things you can do with
   phpSecureSite.

   Currently phpSecureSite is meant for a closed application,
   where users must log in to use it, so using it for other
   purposes will not be discussed.

   The first thing you need to do is to load phpSecureSite. To do
   this, simply load the main file like this:
   require("/opt/phpsecuresite/phpss/phpss.php"). This will set
   up phpSecureSite, and must be done in every script you plan on
   using it.

   There are three main functions which are used to interface
   with phpSecureSite; phpss_login(), phpss_validate() and
   phpss_logout(). We will have a look at each of these here, and
   look at an example in a later section.

   We'll start off with phpss_login(). This function is used to
   authenticate users, and if the user provided a correct
   username and password it will also set up the session for the
   client. It takes two arguments; username and password, and
   returns a status code indicating the action to be taken. A
   list of these return codes is available in the phpss_login()
   function reference. Usernames and passwords are handled in a
   case-sensitive fashion.

   phpss_validate() is the function which restricts access to a
   page to authenticated users. It will check if the session is
   valid, and perform some other checks to make sure the user is
   allowed access. It doesn't take any arguments, and returns a
   status code indicating what should be done. A list of these
   status codes is available in the phpss_validate() function
   reference.

   Since phpss_validate() needs to be called on every page in
   your application, it is best to set up a wrapper-function for
   it which is included through a global-include. A global
   include is a file which is included at the very start of every
   page in your application, and performs actions which are
   common to every script. The wrapper function is a function
   which calls phpss_validate() and then performs an action based
   on its return code. By doing it this way we only need to call
   the wrapper function in every script, instead of also defining
   all the checks on every page in your app - this would result
   in alot of code duplication, which is not good for alot of
   reasons (difficult to make changes being the most important).
   An example of this is available later in the chapter.

   Both phpss_login() and phpss_validate() set up a couple of
   global variables; $phpss_account containing the current
   accounts ID, and $phpss_sessionkey which contains the current
   sessions key. These may be useful for example to fetch and
   present information about the current user.

   phpss_logout() destroys the client's session, ie logs the user
   out. It doesn't take any arguments, and doesn't return
   anything either. Just call it, and the user can be considered
   logged out.

   This is everything you need to know about phpSecureSite in
   order to use it. We will have a look at an example in a later
   section, which may help clarify things if you feel confused.
     _________________________________________________________

4.2. Accessing the database

   It may be a good idea to use a common database both for
   phpSecureSite and your application. By doing so you only need
   to open one database link when you execute a script, instead
   of two. To do this you will need to access the database
   through phpSecureSites database functions. You also need to
   make sure phpSecureSite is loaded in all scripts, even if you
   don't use any of phpSecureSites other functionality.

   The database link will automatically be created when you load
   phpSecureSite, so you can just go ahead and run queries
   against the database. To execute a query you use the function
   phpss_db_query(). This function takes the database query as an
   argument, and returns the result as a matrix. A matrix is a
   two-dimensional array, where the first element is the row
   number, and the second is the column number.

   For example, to print the third column of the seventh row you
   would do this: print($result[6][2]);. and to count the number
   of rows in the result set you simply run sizeof($result);. To
   go through the result one row at a time you run
   foreach($result AS $row).

   It is very important that you escape special characters in any
   external data you put in a query, for example form data you
   send to the database. If you don't, people can manipulate your
   queries to get information they should not have access to.
   This can be done by running phpss_db_escape_string() on the
   data first, which will return the data with special characters
   escaped so that it is safe to place in a query.

   Also, don't access the phpSecureSite tables directly, use the
   functions provided by phpSecureSite to fetch and update data.
     _________________________________________________________

4.3. The cache system

   phpSecureSite uses a cache system to temporarily store data
   fetched from databases. This way, when a subsequent request
   for the data comes, it can be retreived from the cache (in
   memory) rather than from the database. The system can be
   enabled or disabled in the config.

   Usually developers won't notice the cache system, but if they
   decide to directly update data in the phpSecureSite database
   then they should empty the related cache so that the updated
   information will be used in future requests.

   Emptying the cache is done by a call to phpss_cache_clear(),
   and pass a cache identifier. A list of identifiers is
   available in the Cache stores reference. For example, to clear
   the account data cache in the core system you would run this
   command:

phpss_cache_clear("phpss", PHPSS_CACHE_ACCOUNTDATA, PHPSS_MODULE_CORE);
     _________________________________________________________

4.4. Using additional account data

   phpSecureSite provides a few functions for fetching account
   data, you can have a closer look at these in the
   Authentication and account/group data function reference.
   However, the account data you can retreive through
   phpSecureSite is very minimal, and in most cases you would at
   least want to store a persons full name and email address.

   The recommended way to store any additional data for accounts
   is to create a separate table for this data, with an ID or
   accountfid foreign key to link it against the account. Then
   create a few functions for getting this additional data
   whenever you need to.
     _________________________________________________________

4.5. A simple example application

   For this example we will assume that the application is placed
   under /var/www/htdocs/, and that phpSecureSite has been
   installed into /opt/phpsecuresite/. You should also have
   configured it for use in your environment.
     _________________________________________________________

4.5.1. Login form

   /var/www/htdocs/loginform.php

   We'll start off with the login form. This is a pure HTML form
   which asks for a username and password. Let's take a look at
   the source code.

<html>
<body>

<form action="login.php" method="post">
        Username : <input type="text" name="username"><br>
        Password : <input type="password" name="password"><br>
        <input type="submit" value="Log in">
</form>

<body>
</html>

   There shouldn't be any surprises here. A simple HTML form with
   a text-input box for the username, a password box for hidden
   password entry, and a submit button which sends the form input
   to login.php as POST variables.
     _________________________________________________________

4.5.2. Login script

   /var/www/htdocs/login.php

   Next, we'll write the script which takes care of logging users
   in. This script takes a username and password, which was
   passed from the login form as POST variables, and checks them
   against the authentication backend, creating a session if
   successful.

<?php

// load phpSecureSite
require("/opt/phpsecuresite/phpss/phpss.php");

// check the username and password
$status = phpss_login($_POST['username'], $_POST['password']);

// check if the user is allowed access
switch ($status) {

        case "phpss_login_allow":
                header("Location: secret.php"); // login successful, re
direct to secret page
                exit();
                break;

        case "phpss_login_authfail":
                print("You entered a wrong username or password");
                break;

        case "phpss_login_bruteforce_accountlock":
                print("Account is locked for logins");
                break;

        case "phpss_login_bruteforce_iplock":
                print("IP address is locked for logins");
                break;

        case "phpss_ipaccess_deny":
                print("Logins not allowed from your IP address");
                break;

        default:
                print("Unknown return code when authenticating user");
}

?>

   We start by loading phpSecureSite. This is done through a
   normal require() call. This sets up everything we need in
   order for us to it.

   Next, we send the username and password, which was passed from
   the HTML form, to phpss_login(). This will validate it through
   the authentication module, and return a value based on the
   result. The result is stored in the $status variable. If the
   login was successful, a session is created.

   Then we check the value of $status to see what we should do
   next. If the login was successful ("phpss_login_allow"), we
   redirect the user to the secret page. If not, we print a
   message for the user.
     _________________________________________________________

4.5.3. Global-include

   /var/www/htdocs/include/global.php

   This script is what we call a "global-include". That means
   that it will do some things that are common to almost all
   scripts in our application. By setting these in one file, we
   can simply load this file using require() in every page, and
   avoid having to duplicate our code on all pages.

   In this case the global-include has a rather simple task; to
   load phpSecureSite and define a so-called "wrapper function".
   This wrapper function will call phpss_validate() and then
   check its return value and execute an appropriate action. We
   can then simply call the wrapper function wherever we need it
   in our application scripts, and this way we'll avoid alot of
   code duplication. Let's have a look...

<?php

// load phpSecureSite
require("/opt/phpsecuresite/phpss/phpss.php");

// define a phpss_validate() wrapper function
function authwrapper() {

        // call phpss_validate()
        $status = phpss_validate();

        // check the return value
        switch($status) {

                case "phpss_validate_allow":
                        break;  // access is allowed, do nothing

                case "phpss_validate_nosession":
                        exit("You need to be logged in to access this p
age");
                        break;

                case "phpss_validate_acl_deny":
                        exit("You do not have permission to view this p
age");
                        break;

                case "phpss_validate_hijack_fail":
                        exit("Your IP address has changed");
                        break;

                case "phpss_validate_ipaccess_deny":
                        exit("Access is not allowed from your IP addres
s");
                        break;

                case "phpss_validate_timeout_fail":
                        exit("You session has timed out, please log in
again");
                        break;

                default:
                        exit("Unknown return code when authorizing sess
ion");
        }
}

?>

   First we load phpSecureSite, this way we won't have to
   explicitly load it on every page.

   We also define a wrapper function, authwrapper(). In the
   wrapper we call phpss_validate() and place the return value in
   $status. Then we check the return value. If the value is
   "phpss_validate_allow" access is allowed, and we do nothing
   (the function will then exit without doing anything more). If
   the return code is something else we stop script execution by
   calling exit() with a message explaining why access was
   denied. A description of the return codes is available in the
   phpss_validate() function reference.

   When we call authwrapper() in a page it will be just as if we
   had simply called phpss_validate(), but it also checks the
   return value.
     _________________________________________________________

4.5.4. Secret page

   /var/www/htdocs/secret.php

   Now we'll take a look at how a private page is made. This page
   will only be accessible by authenticated users with a valid
   session. Since we have set up a global-include which defines a
   wrapper for phpss_validate() this is really simple. Have a
   look:

<?php

// load the global-include
require("include/global.php");

// check if the session is valid
authwrapper();

?>
<html>
<body>

Welcome to the secret page! Nothing of interest here...
<p>
You may now <a href="logout.php">log out</a>.

</body>
</html>

   Simple, wasn't it? First we load out global include
   include/global.php, which loads phpSecureSite and then defines
   the authwrapper() function. Then we call authwrapper(), which
   in turn calls phpss_validate() and then checks the return
   codes and takes appropriate action. If everything went ok, the
   script continues by printing a simple html page.

   This is all you will really need to do to enable phpSecureSite
   in your application. Just add the authwrapper() call (and load
   the global-include if you don't already have one) and you're
   good to go.

   The "log out" link points to the logout.php script, which is
   the last script in out small application. We'll have a look at
   this next.
     _________________________________________________________

4.5.5. Logout script

   /var/www/htdocs/logout.php

   This script will destroy a session, in effect logging a user
   out, and then redirect the user to the login form.

<?php

require("include/global.php");

// check that we actually have a valid session to destroy
authwrapper();

// destroy the session
phpss_logout();

// redirect to login form
header("Location: loginform.php");

?>

   This script probably don't even need an explanation, but
   you'll get one in any case.

   We first load phpSecureSite through the global-include, which
   also sets up authwrapper(). We then check that the user
   actually has a valid session that we can destroy by calling
   authwrapper(). Then we destroy the session by calling
   phpss_logout(), which deactivates the session in the database,
   and removes the client cookie. Then it redirects the user to
   the login form, so he can log in again.

   That's all there is to it. I hope you'll find phpSecureSite
   useful in your own application.
     _________________________________________________________

4.6. Security considerations

   Even though phpSecureSite is designed to take care of as much
   as possible of the security of a web-application it is not
   magic pixie dust that will make your application impregnable.
   Misconfigurations, poor infrastructure security, bad code and
   other factors can make all the security provided by
   phpSecureSite useless. Here are a few tips for making your
   application secure.

     * Run your application over SSL (Secure Socket Layer) or TLS
       (Transport Layedr Security). SSL and TLS encrypts the data
       which is sent back and forth between the client and the
       web server. If you don't encrypt the data, it can easily
       be picked up from the network and people can get access to
       session data and even sensitive data which may be
       transmitted. Most web-servers today come with SSL and/or
       TLS, ask your sysadmin for info. Also, to avoid session
       hijacking, check out the hijack (session hijacking
       countermeasures) module.
     * Escape special characters in data which you place in SQL
       queries. If you don't, then crackers can put special
       characters in form data etc which will manipulate your SQL
       queries. If you use the same database for phpSecureSite
       and your application (see the Accessing the database
       section) then you can use the phpss_db_escape_string()
       function.
     * Urge your users to use secure passwords. Many users have
       extremely simple passwords (such as "password", "12345678"
       or "sex"), these can be easily guessed by crackers to gain
       access to an account. Random combinations of capital
       letters, small letters and numbers, with eight or more
       characters, are best. Also see the bruteforce (bruteforce
       attack protection) module.
     * Only give information to people who should have access to
       it. When someone requests a specific data item you should
       make sure that the user making the request is the owner of
       the data (for example for viewing customer receipts in a
       web-store). You can use the acl (access control lists)
       module to restrict access to a page to specific users.
     * Turn off the register_globals setting for PHP. If it is
       enabled, crackers can make your application do unexpected
       things by setting script variables through GET variables
       etc.
     * Make sure your network infrastructure is secure. Use
       firewalls and other security devices, and only give access
       to services which needs to be accessed (don't leave your
       database server open for the whole Internet, for example).
       A good policy is "that which is not explicitly allowed, is
       denied".
     * Keep your software up-to-date. Most projects and vendors
       have mailing lists which notify you of important upgrades
       and security problems in the software - make sure you are
       on them.
     _________________________________________________________

4.7. More examples

   The application example earlier in this chapter is only a very
   simple and minimal example on how to use phpSecureSite. The
   system is built to be as flexible as possible, and this
   section will give a few examples of how to do other things
   with phpSecureSite.

   All these examples use the example earlier in this chapter as
   a basis, anything which is not explicitly changed can be used
   from there.
     _________________________________________________________

4.7.1. Displaying login errors in the login form

   Some people may want to display "login denied" and similar
   messages in the login form page itself, so users don't have to
   click the back button to try again. This is easy.

   Change the loginform.php script to send the username and
   password to itself, and run the checks there. Redirect the
   user to the secret page if login is successful, or print an
   error and the login form in any other case. You can also
   remove the login.php script.Here is one way to do this:

<?php

// load phpSecureSite
require("/opt/phpsecuresite/phpss/phpss.php");

$failmessage = "";

// handle form submit
if (sizeof($_POST) > 0) {

        // check the username and password
        $status = phpss_login($_POST['username'], $_POST['password']);

        // check if the user is allowed access
        switch ($status) {

                case "phpss_login_allow":
                        header("Location: secret.php"); // login succes
sful, redirect to secret page
                        exit();
                        break;

                case "phpss_login_authfail":
                        $failmessage = "You entered a wrong username or
 password";
                        break;

                case "phpss_login_bruteforce_accountlock":
                        $failmessage = "Account is locked for logins";
                        break;

                case "phpss_login_bruteforce_iplock":
                        $failmessage = "IP address is locked for logins
";
                        break;

                case "phpss_ipaccess_deny":
                        $failmessage = "Logins not allowed from your IP
 address";
                        break;

                default:
                        $failmessage = "Unknown return code when authen
ticating user";
        }
}

?>
<html>
<body>

<?php if($failmessage != "") print("Login denied: " . $failmessage . ".
 please try again<br>\n"); ?>

<form action="<?php print($_SERVER["SCRIPT_NAME"]); ?>" method="post">
        Username : <input type="text" name="username"><br>
        Password : <input type="password" name="password"><br>
        <input type="submit" value="Log in">
</form>

<body>
</html>
     _________________________________________________________

4.7.2. Redirect to login form if not logged in

   Sometimes you may want to redirect users to the login form
   when they try to access a page without having logged in. To do
   this, we will change the include/global.php script so that it
   redirects user to loginform.php whenever we get a
   phpss_validate_nosession return code (we still want the other
   messages to be printed).

<?php

// load phpSecureSite
require("/opt/phpsecuresite/phpss/phpss.php");

// define a phpss_validate() wrapper function
function authwrapper() {

        // call phpss_validate()
        $status = phpss_validate();

        // check the return value
        switch($status) {

                case "phpss_validate_allow":
                        break;  // access is allowed, do nothing

                case "phpss_validate_nosession":
                        header("Location: loginform.php"); // redirect
to login form if not logged in
                        exit();
                        break;

                case "phpss_validate_acl_deny":
                        exit("You do not have permission to view this p
age");
                        break;

                case "phpss_validate_hijack_fail":
                        exit("Your IP address  has changed");
                        break;

                case "phpss_validate_ipaccess_deny":
                        exit("Access is not allowed from your IP addres
s");
                        break;

                case "phpss_validate_timeout_fail":
                        exit("You session has timed out, please log in
again");
                        break;

                default:
                        exit("Unknown return code when authorizing sess
ion");
        }
}

?>
     _________________________________________________________

4.7.3. Case-insensitive usernames

   If you want your usernames to be case-insensitive, you first
   need to make sure that all usernames are stored in lowercase
   in the authentication backend. Then you simply change the
   phpss_login() call in login.php so that it converts the given
   username to lowercase first, like this: $status =
   phpss_login(strtolower($_POST["username"]),
   $_POST["password]);.

   A similar approach can be used with passwords too. However, in
   that case the password must be stored in plaintext. If a hash
   of it is stored then the hash computed for the inputted
   password will be completely different when you change the case
   of some characters, and they won't match.
     _________________________________________________________

Chapter 5. Administration

5.1. Introduction

   phpSecureSite doesn't include an administration tool, so
   everything will have to be done manually. An admin-tool is
   planned for a later release, but development will not be
   started until phpSecureSite has stabilized a bit, and most
   important functionality has been implemented. Don't expect it
   anytime soon.
     _________________________________________________________

5.2. Managing user accounts

   This section assumes you are using the database authentication
   handler. Other authentication handlers have different methods
   of managing user accounts.

   Managing accounts involves using SQL queries directly against
   the database server. If you aren't too familar with SQL you
   can use a database administration tool such as phpMyAdmin for
   MySQL, or phpPgAdmin for PostgreSQL.
     _________________________________________________________

5.2.1. Adding users

   User accounts are created by adding entries to the table
   phpss_account. This table has four columns; id, username,
   password and active. The id is an auto-incrementing column, so
   you won't need to set anything here. This is just a unique
   identifier for the account used internally by phpSecureSite.
   Username is, as the name implies, the username of the account,
   password is the account password, and active sets whether or
   not the account is active (allowed to be used). You normally
   won't need to set anything for the active column as it
   defaults to active.

   The password column is a bit special. phpSecureSite will
   expect passwords to be stored in a specific format - see the
   Authentication options for info on configuring it. If you plan
   on having functionality such as mailing passwords to users who
   have forgotten it you must store the password in plaintext
   format, as encrypted passwords can only be retreived by
   already knowing the password (they use themselves as an
   encryption key).

   If you would like to create an account with a plaintext
   password you would run a query such as this:

mysql> INSERT INTO phpss_account (username, password) VALUES ('newuser'
, 'secretpassword');
Query OK, 1 row affected (0.00 sec)

   Let us say you would like to store passwords in md5 format,
   scrambling them so that neither you, as an admin, or other
   database users (or crackers) are able to access them, you
   could use this query :

mysql> INSERT INTO phpss_account (username, password) VALUES ('newuser'
, MD5('secretpassword'));
Query OK, 1 row affected (0.00 sec)

   If your database backend doesn't support the MD5() function,
   you may use other means of generating the md5 string (such as
   using the UNIX md5 command) and insert the resulting string as
   if it was a plaintext password.
     _________________________________________________________

5.2.2. Deleting users

   Accounts could have been deleted simply by removing their
   entry from the account table, but usually you really don't
   want to do this. Deleting accounts means that all sessions,
   log entries and other data that is bound against the account
   no longer have an owner, and in effect loses some of their
   usefulness. So instead of deleting an account it is better to
   simply deactivate it. This is easily done by setting the
   account.active field to 0. If you, at a later time, would like
   to re-active the account you just set this field to 1.

   If you want to deactivate the 'myuser' account you would run a
   query like this :

mysql> UPDATE phpss_account SET active = 0 WHERE username = 'myuser';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

   And for reactivating the account you run a similar query :

mysql> UPDATE phpss_account SET active = 1 WHERE username = 'myuser';
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
     _________________________________________________________

5.2.3. Managing groups

   Groups are currently only used by the acl (access control
   lists) module for defining page access based on group
   memberships, but it will probably be used for other things in
   the future.

   Groups are added by inserting an entry into the phpss_group
   table. A group only has a name field, so this is easy:

mysql> INSERT INTO phpss_group (name) VALUES ('newgroup');
Query OK, 1 row affected (0.00 sec)

   Deleting a group is just as easy. However, when you delete a
   group you should also remember to delete all group memberships
   for this group, so that no accounts are members of
   non-existant groups.

mysql> DELETE FROM phpss_group WHERE id = 7;
Query OK, 1 row affected (0.01 sec)

mysql> DELETE FROM phpss_account_group WHERE groupfid = 7;
Query OK, 1 row affected (0.00 sec)
     _________________________________________________________

5.2.4. Group memberships

   An account is made a member of a group by inserting an entry
   into the phpss_account_group table. A group membership
   consists of an account id and a group id, specifying that
   account x is member of group y.

   When creating group memberships you need to know the id of
   both the account and the group. When you have this you run a
   query:

mysql> INSERT INTO phpss_account_group (accountfid, groupfid) VALUES (1
8, 5);
Query OK, 1 row affected (0.00 sec)

   Consequently, removing an account from a group is only a
   matter of removing the corresponding entry from the same
   table:

mysql> DELETE FROM phpss_account_group WHERE accountfid = 18 AND groupf
id = 5;
Query OK, 1 row affected (0.00 sec)
     _________________________________________________________

Chapter 6. Modules

   phpSecureSite uses modules for most functionality outside the
   core system, so you can adapt it to your needs. This chapter
   contains a description of the modules that are included in the
   phpSecureSite distribution.

   Current modules are divided into four categories;
   authentication modules, database modules, log modules and
   normal modules.
     _________________________________________________________

6.1. Database modules

   Database backend modules handles basic database communication,
   such as connecting and executing queries.
     _________________________________________________________

6.1.1. mssql (Microsoft SQL Server)

   modules/database/mssql.php

   This module lets you use a Microsoft SQL Server as a backend
   for phpSecureSite.

   Configuration options

   hostname
          Address of database server, both an IP address and a
          DNS name is accepted.

   username
          Username to use when connecting.

   password
          Password to use when connecting.

   database
          Name of the database to use
     _________________________________________________________

6.1.2. mysql

   modules/database/mysql.php

   This module lets you use a MySQL database server as a backend
   for phpSecureSite.

   Configuration options

   hostname
          Address of database server, both an IP address and a
          DNS name is accepted.

   port
          Port number on which the server is listening (MySQL
          uses port 3306 by default).

   username
          Username to use when connecting.

   password
          Password to use when connecting.

   database
          Name of the database to use
     _________________________________________________________

6.1.3. pgsql (PostgreSQL)

   modules/database/pgsql.php

   This module lets you use a PostgreSQL database server as a
   backend for phpSecureSite.

   Configuration options

   hostname
          Address of database server, both an IP address and a
          DNS name is accepted.

   port
          Port number on which the server is listening
          (PostgreSQL uses port 5432 by default).

   username
          Username to use when connecting.

   password
          Password to use when connecting.

   database
          Name of the database to use
     _________________________________________________________

6.2. Authentication modules

   Authentication modules takes care of communication with the
   authentication backend. It authenticates users by checking a
   supplied username and password, and it also retreives account
   and group data from the backend.

   Note

   If you will be using the phpSecureSite database as an
   authentication source (which in most cases is what you want)
   then you should use the database module.
     _________________________________________________________

6.2.1. database

   modules/auth/database.php

   The most commonly used authentication module. It uses the
   normal phpSecureSite database as an authentication backend,
   and does lookups over the normal database link.
     _________________________________________________________

6.2.2. ldap

   modules/auth/ldap.php

   Perform authentication against an LDAP directory server.
   Requires LDAP support in php.

   The modules uses the posixAccount and posixGroup schemas for
   authenticating users.

   Configuration options

   hostname
          The address of the LDAP server, either a DNS name or an
          IP address.

   port
          The port number of the LDAP server.

   binddn
          The DN to bind to the server as

   bindpw
          The password to use when binding

   basedn
          The base DN to search under.
     _________________________________________________________

6.2.3. mysql

   modules/auth/mysql.php

   Performs authentication against a separate MySQL database.
   Mostly meant for use against an already existing account
   database, such as for email accounts.

   Note

   If you store accounts in the normal phpSecureSite database,
   then use the database module instead.

   Configuration options

   hostname
          Database server address, both IP address and DNS name
          is accepted.

   port
          The port number on which the server is listening (MySQL
          uses port 3306 by default).

   username
          The username to use when connecting.

   password
          The password to use when connecting.

   database
          The database to use.

   query_auth
          Query used for authenticating users. %u will be
          replaced with the username, and %p with the password.
          It must return three fields; account id, username and
          password.

   query_accountdata
          Query for fetching accountdata. %i will be replaced
          with the account id. If must return three fields; id,
          username and password.

   query_accountid
          Query for looking up an account id based in a username.
          %u will be replaced with the username. It must return
          one field containing the account id.

   query_accountgroupd
          Query for looking up the groups an account is a member
          of. If you do not have any groups you can just set the
          query empty. %i will be replaced with the account id.
          It must return the group ids one per row, in the first
          column.

   query_groupdata
          Query for fetching group data. If you have no groups
          you can set this empty. %i will be replaced with the
          group id. It must return two fields; id and groupname.

   query_groupid
          Query for looking up a group id from a group name. If
          you have no groups you can set this empty. %g will be
          replaced with the group name. It must return the group
          id as the first field.
     _________________________________________________________

6.2.4. pgsql (PostgreSQL)

   modules/auth/pgsql.php

   Performs authentication against a separate PostgreSQL
   database. Mostly meant for use against an already existing
   account database, such as for email accounts.

   Note

   If you store accounts in the normal phpSecureSite database,
   then use the database module instead.

   Configuration options

   hostname
          Database server address, both IP address and DNS name
          is accepted.

   port
          The port number on which the server is listening
          (PostgreSQL uses port 5432 by default).

   username
          The username to use when connecting.

   password
          The password to use when connecting.

   database
          The database to use.

   query_auth
          Query used for authenticating users. %u will be
          replaced with the username, and %p with the password.
          It must return three fields; account id, username and
          password.

   query_accountdata
          Query for fetching accountdata. %i will be replaced
          with the account id. If must return three fields; id,
          username and password.

   query_accountid
          Query for looking up an account id based in a username.
          %u will be replaced with the username. It must return
          one field containing the account id.

   query_accountgroupd
          Query for looking up the groups an account is a member
          of. If you do not have any groups you can just set the
          query empty. %i will be replaced with the account id.
          It must return the group ids one per row, in the first
          column.

   query_groupdata
          Query for fetching group data. If you have no groups
          you can set this empty. %i will be replaced with the
          group id. It must return two fields; id and groupname.

   query_groupid
          Query for looking up a group id from a group name. If
          you have no groups you can set this empty. %g will be
          replaced with the group name. It must return the group
          id as the first field.
     _________________________________________________________

6.3. Log modules

   Log modules writes log entries to various backends.
     _________________________________________________________

6.3.1. database

   modules/log/database.php

   Inserts log entries into the phpss_log table in the
   phpSecureSite database.
     _________________________________________________________

6.3.2. file

   modules/log/file.php

   Sends log messages to a plain-text file, or to a command
   through a pipe, in a user-specified format.

   Configuration options

   file
          The file which log messages should be written to. If
          this starts with a | (pipe), it will instead execute
          the command following the | and pass the log data to it
          through stdin.

   format
          The format in which log messages should be written. You
          can use special expansion identifiers which will be
          replaced with actual data when the entry is generated:

          + %% : A percent sign
          + %a : Account id (0 if not logged in)
          + %A : Account name (username)
          + %c : Log class
          + %i : IP address of the client
          + %l : Log message
          + %L : Extra information
          + %m : Module which sent the message
          + %M : Type of module
          + %s : Session id
          + %S : Session key
          + %t : Time in UNIX timestamp format
          + %T : Time in ISO format
          + %u : Page URI
     _________________________________________________________

6.3.3. syslog

   modules/log/syslog.php

   Sends log messages to the syslog on UNIX systems (on Windows
   it is supposed to be sent to the Event Viewer, but it has
   never been tested).

   The module maps the message class to the corresponding syslog
   classes, wo you can use them for filtering.

   Warning

   If you have configured apache to use syslog for logging as
   well, Apache will not reset it's log ident and facility, and
   will send log messages using the phpss ident. Do not use this
   module if your Apache installation is using syslog for
   logging.

   Configuration options

   facility
          The facility ("category") to use for logging messages.
          A list of constants for use here can be found in the
          syslog(3) man page. Default is LOG_AUTHPRIV.
     _________________________________________________________

6.4. Normal modules

   Normal modules extends phpSecureSite with various kinds of
   functionality.
     _________________________________________________________

6.4.1. acl (access control lists)

   modules/acl.php

   This module adds access control lists to phpSecureSite. These
   are used to define a set of users who are allowed to access a
   page.

   Currently you can only define the acls in the scripts by using
   functions that are provided by this module. This means that
   you must set an acl on each and every page you want it. In
   future versions you should be able to set this in a database,
   so that you can for example set an acl for all files under a
   specific directory. In order to make the current solution as
   easy to use as possible it is recommended that you base your
   acls on groups, and then add and remove accounts in the groups
   to control access. You could also set up different files which
   only contain calls to the acl functions, and then include
   these files in the respective scripts.

   You can set accesses for accounts/groups by using the
   functions phpss_acl_set_account_access()
   phpss_acl_set_group_access(), phpss_acl_set_policy() and
   phpss_acl_set_preferred(). More information on these, and
   other, functions can be found in the ACL function reference.

   The acl checking is done in phpss_validate(), so the acls must
   be defined before it is called.

   The order in which the ACLs are checked is as follows:

    1. Account access: Has access rules for the account been set
       explicitly? If so, use this access. If several access
       rules are set for the account, the last one that was
       defined is used.
    2. Group access: Has access rules been set for any of the
       groups which the account is a member of? If so, the access
       is used. If access rules are set for several of the
       accounts groups, and these are conflicting, then the
       preferred access is used. The preferred access is defined
       in the acl module config, but can be changed with
       phpss_acl_set_preferred().
    3. Policy: The acl policy will be used. This is defined in
       the acl config, and can be changed using
       phpss_acl_set_policy(). If the policy is set multiple
       times, the last value will be used.

   Configuration options

   policy
          Sets the default access policy. This will be used if no
          matching acl rules are found.

   preferred
          Sets the default preferred access. This is used when an
          accounts groups have conflicting access rules.

   This is a simple example of an access control list. We use the
   authwrapper() from earlier examples.
require("phpss.php");

phpss_acl_set_policy("deny"); // set default access to deny

phpss_acl_set_group_access(2, "allow"); // allow access for the account
ing department

phpss_acl_set_account_access(1, "allow"); // steve from management shou
ld have access
phpss_acl_set_account_access(7, "deny"); // monica in accounting is onl
y a temp, no access

authwrapper();
     _________________________________________________________

6.4.2. bruteforce (bruteforce attack protection)

   modules/bruteforce.php

   This module provides protection against brute force
   account/password guessing attacks. Brute force attacks are
   attacks where a cracker will typically use a dictionary, list
   of words, or just try all possible combinations of letters and
   numbers in order to gain access to an account. These attacks
   are often automated, and the guessing rate can be several
   hundred attempts per second.

   This module separates brute force attacks into two groups;
   account based and source ip-address based. Both can be enabled
   or disabled independently, and they have their own
   configuration options.

     * Source IP based protection records every failed login
       attempt together with the IP address the login attempt
       came from. When too many failed login attempts have been
       recorded, the IP address will be denied further login
       attempts.
     * Account based protection will record all failed login
       attempts where a correct username was given, but the
       password was wrong. When too many failed login attempts
       have been recorded, the account will be denied further
       login attempts.

   Of course, if both account and ip based protection is enabled,
   a failed login attempt to an existing account will be recorded
   both as a source IP fail and as an account fail. Whenever a
   user successfully logs in, all fail records, both for the
   account and for the IP address, will be removed. In other
   words; the counters will be reset to zero.

   Usually you should really enable both of these, using only one
   or the other have their obvious flaws. When only ip based
   protection is enabled, a user with a valid account on your
   system would be able to first guess an account/password
   combination, then log in using his own account to reset his
   IPs fail counter, then try another combination. Using only
   account based protection would allow any attacker to run an
   attack where he tries all combinations of user names using
   only one password (it is frightening how many users have silly
   passwords such as the old classic "password", or just a blank
   password).

   Configuration settings

   account_enable, ip_enable
          When true, this will activate account or ip based
          protection.

   account_threshold, ip_threshold
          This value sets the number of failed logins that are
          allowed before the account or IP address is locked.

   account_thresholdtime, ip_thresholdtime
          This sets the time period (in seconds) in which the
          threshold must be exceeded. If, for example, your
          threshold is 5 and the thresholdperiod is 60, it means
          that a lock is set only if there are 5 failed logins
          within 60 seconds. Set to 0 to disable.

   account_locktime, ip_locktime
          This sets how long (in seconds) a lock will be in
          place, before it is removed. When set to 0 the lock
          will never be removed.
     _________________________________________________________

6.4.3. cachecontrol (control cache policies using http headers)

   modules/cachecontrol.php

   Caching is widely used by both web proxies and browsers to
   store copies of received web-pages, so they won't have to be
   re-sent over the network during a later request. This is done
   both in order to reduce download times for the client, and to
   spare the server for any extra work. However, when writing
   dynamic web applications, it may not always be desirable to
   have web-pages cached, both because old, outdates copies of
   the web-pages may be displayed to the user, but also because
   shared caches (such as web proxies) may send private
   information for one user, to other clients using the same
   cache.

   This module lets you define caching policies. HTTP headers are
   generated based on the policy you choose, and all browsers and
   proxies should (unfortunately, some don't) treat the web-pages
   according to these headers.

   The policies you can set are the following:

   nocache
          Forces the server to retransmit the web-page with every
          request. This will ensure that users always have an
          updated version of the web-page, Note that this will
          have a very negative impact on network traffic and
          server load.

   Note

   Both browsers and caches have algorithms for determining if a
   cached copy should be used or not, so don't be too afraid to
   use "private" or "public" caching.

   private
          This will allow private caches, such as your browser's
          cache, to store copies of the web-page, but instruct
          public ones, like web proxies, not to.

   public
          The web-page may be cached by both private and public
          caches (browsers, web proxies and so on).

   Configuration settings

   policy
          Sets the caching policy. Valid values are nocache,
          private and public. See above for information on each.

   revalidate
          If set to true, the cached copy will always be
          revalidated against the current copy on the server (bot
          not necessarily be transferred if already up-to-date).
          Recommended turned on.
     _________________________________________________________

6.4.4. hijack (session hijacking countermeasures)

   modules/hijack.php

   Session hijacking is a very simple and effective way to gain
   access to an account, especially if the http traffic is going
   unencrypted over the network. When a user logs in,
   phpSecureSite sets a cookie in the client browser. A cookie is
   a small piece of data which is sent to the server every time
   the client makes a page request. This cookie contains a
   32-byte string which uniquely identifies the user, and this is
   what lets phpSecureSite see which requests come from Bob, and
   which come from Mary. If a cracker is able to get hold of this
   string, he can easily create a copy of the ID cookie in his
   own browser. Whenever he then makes a request to your
   application it will think the cracker is the valid user
   (because the cookie has the exact same id string).

   When phpSecureSite creates a session (logs a user in) it also
   records which IP address the user logged in from. This module
   checks if the IP address from which a request is sent is the
   same as the address the user logged in from. If it is
   different, access will be denied. Please note that there are
   legitimate reasons for why a client's IP address would change;
   round-robin web proxy systems, dynamic IP addresses (dhcp) and
   other things.
     _________________________________________________________

6.4.5. ipaccess (client ip access control)

   modules/ipaccess.php

   This module lets you control access based on the IP address of
   the client. You can set global access rules (which apply to
   everyone), per-account access rules (which apply to specific
   accounts only) and per-group access rules (which apply to
   specific groups only). Global rules are placed in the
   phpss_ipaccess database table, account rules in
   phpss_ipaccess_account, and group rules in
   phpss_ipaccess_group. Access rules apply to every page in the
   application. It is currently not possible to use IP-based
   access on a per-page basis.

   Access rules are checked in the order below, until a matching
   rules is found.

    1. Account rules are checked first.
    2. Group rules are checked next. If an account is member of
       several groups, and these have conflicting rules, the
       preferred access will be used (see configuration option
       below).
    3. Global rules are checked last.

   If no matching rules are found, then the access policy will be
   used (see config option below).

   Configuration settings

   policy
          This defines the access policy, or default access. If
          no matching rules can be found, this is used as a
          fallback. Valid values are allow and deny.

   preferred
          Here you set the preferred access to be used when
          conflicting group access rules are set (when an account
          is a member of several groups, and these have different
          access rules). Valid values are allow and deny.
     _________________________________________________________

6.4.6. loginfaildelay (delays failed login attempts)

   modules/loginfaildelay.php

   This module sets a delay before login denied messages are
   sent. This can be used to slow down attackers who are guessing
   usernames/passwords or running bruteforce attacks. It will not
   affect successful login attempts. Also see the bruteforce
   (bruteforce attack protection) module.

   This is an extremely simple module, and a great example if you
   want to have a look at how the module system works.

   Configuration settings

   delay
          The number of seconds to delay the login failed
          messages.
     _________________________________________________________

6.4.7. svars (session variables)

   modules/svars.php

   One of the most useful services a session handling system
   should provide are session variables. Usually, in web
   development, when you set a variable that variable will only
   be valid for that script or request. You can not pass a
   variable between different scripts without using POST or GET
   variables, which quickly gets messy and are also easily
   changed by the client. Session variables will let you store a
   variable in the session system, and then retrieve that
   variable in another script (page request). Session variables
   are also bound to the session they were created for, and are
   perfect for storing for example shopping cart contents.

   In order to store a session variable you use the
   phpss_svars_set() function, and you retrieve it using
   phpss_svars_get(). For example, to store a variable named
   myvar as the session variable sessionvar, you would run the
   call as phpss_svars_set("sessionvar", $myvar). In order to
   retrieve it in another page you would run
   phpss_svars_get("sessionvar").

   The svars module supports all datatypes that PHP supports,
   except resource types. This includes strings, integers and
   arrays.

   When phpss_validate() is called, the svars module
   automatically fetches all session variables for the current
   session and makes them available through the $phpss_svars
   array. This can be disabled by setting the autoset config
   option to false.

   Configuration settings

   autoset
          When this is set to true, phpSecureSite will
          automatically make all session variables available
          through the $phpss_svars array when phpss_validate() is
          called. New session variables will also be
          added/updated in this array when phpss_svars_set() is
          called.
     _________________________________________________________

6.4.8. timeout (session timeouts)

   modules/timeout.php

   This module provides session timeout checks. This means that
   after a client has been inactive (ie no page request has been
   received from the client) for a given period of time, the
   session will be made invalid. This is useful for example if a
   user logs in from a public computer at a library and forgets
   to log out. The next person who uses the computer (assuming
   the predefined timeout period has passed) will then be unable
   to take over the session.

   Configuration settings

   timeout
          The maximum period of inactivity (in minutes) before
          the session will be disabled.
     _________________________________________________________

6.4.9. usertrack (page request tracking)

   modules/usertrack.php

   The usertrack module is used for recording user activity on a
   site. Whenever phpss_validate() is called on a page, and the
   user is authorized to access it, that page request is recorded
   in the database. This can be very handy for generating
   statistics or doing other analysis of user activity.

   The module records the session id, timestamp and URL for the
   request. The session id can be used to look up additional
   information about the session, such as the account which owns
   it. The request data is stored in the database table
   phpss_usertrack_req, while the table phpss_usertrack_url
   contains URLs that have been requested.

   Please note that phpSecureSite does not perform any analysis
   of the data at all, it is up to third-party developers (such
   as yourself) to develop software for analyzing the data.
     _________________________________________________________

Chapter 7. Tools

   phpSecureSite includes tools for handling various
   administrative tasks. These can be found in the tools/
   directory.
     _________________________________________________________

7.1. dbclean (database cleanups)

   tools/dbclean.php

   The dbclean tool performs cleanups of the phpSecureSite
   database, such as removing outdated and corrupt data. It can
   also remove old and unused session to make the system faster,
   but this will remove session data which may be useful when
   reading logs etc.

   To keep the database relatively small and the overall
   performance of the system good, it is recommended that you run
   this script in a cron-job once every night. It can also be run
   via your browser by putting it under the document root of your
   server.

   Configuration is done in the tool file itself, near the top.

   Configuration options

   phpss_path
          The full path to the phpss.php file. dbclean needs to
          load phpSecureSite to fetch its config, access the
          database backend and take advantage of the
          infrastructure it provides.

   idlelimit
          The number of idle hours before a session is considered
          inactive. Data which is no longer useful will be
          removed for these sessions.

   removesessions
          When true, all session data for inactive sessions is
          removed. This should improve the performance of the
          overall system, but will remove data which may be
          useful when reading logs or for historical reference.
     _________________________________________________________

Chapter 8. Module development

8.1. Introduction

   The phpSecureSite module system is relatively simple, but it
   should be powerful and flexible enough to accomodate most
   needs.

   A module is a simple .php file which is loaded using a normal
   require() call. Because they are loaded this way it is
   important that all code is located within function
   definitions. Any code not located in functions will be
   executed when the module is loaded, and this can obviously
   cause all sorts of problems. The only code that should be
   outside of functions is code needed to set up the module, such
   as registering the module and its event hooks etc.

   A module should preferrable be contained in a single .php
   file. Very little validation is done on modules, so it is your
   responsibility as a module developer that it is correct. All
   modules should use their own namespace for variables,
   functions and constants, of the form phpss_<modulename>_name.
   This way you will avoid clashes with phpSecureSite itself or
   the users application. You should also make sure all SQL is
   SQL-99 compliant and properly escaped, and if anything goes
   wrong behind the curtain you should exit with an error message
   using phpss_error().

   If you need to create a database table for your module then
   you are free to do so, but prefix it in the same way you do
   with variables and functions. You should also provide a
   database schema for each of the database servers phpSecureSite
   works with, if possible. Information on accessing
   phpSecureSites database can be found in the Accessing the
   database section earlier in the manual.

   You may also find the Reference chapter of interest.

   Modules are divided into four categories. Each category have
   been given a module type ID, a list of these can be found in
   the Module types reference. This ID is passed to most of the
   module-related functions, so that a database module and a log
   module with the same name won't interfere with each other. All
   module functions defaults to a normal module type.

   normal modules - type PHPSS_MODULE_NORMAL
          Normal modules are the most common module type. These
          extend phpSecureSites functionality, either by
          providing functions which application developers can
          use, or by running a piece of code when an events
          occurs.

   database modules - type PHPSS_MODULE_DATABASE
          Database modules are used for the basic database
          communication. They pretty much just provide code for
          connecting to a database server, and running SQL
          queries against it. All SQL queries in phpSecureSite
          are SQL-99 conformant, and should be accepted by any
          database server that supports SQL-99.

   authentication modules - type PHPSS_MODULE_AUTH
          Authentication modules authenticates users. They
          receive a username and password from phpSecureSite and
          checks it against a list of accounts. They must also
          provide functions for retreiving account data from the
          backend.

   log modules - type PHPSS_MODULE_LOG
          Log modules writes log messages to a certain backend,
          for example an SQL database table, a plain text file or
          a syslog server.
     _________________________________________________________

8.2. Module registration

   Registering a module is the first thing your module needs to
   do. This registers your module with the core phpSecureSite
   system, and gives access to functionality for storing and
   retreiving data and configuration options, among other things.

   The module is registered through a call to
   phpss_module_register(). This call should usually be placed at
   the very top of the script. It takes It takes the name of the
   module as the first argument. and the optional second argument
   lets you specify the type of module you are registering. It
   defaults to a normal module.
     _________________________________________________________

8.3. Configuration options

   Configuration options can be stored in two places; either in
   the module file itself, or in the central phpSecureSite
   configuration files.

   To store configuration settings in the module file you should
   use phpss_module_set_config(). It takes the module name and an
   array of key/value pairs (your config options) as arguments,
   and optionally a third argument specifying the type of module.
   The function call should be placed early in the script so it
   can easily be accessed by users, but it must be placed after
   the phpss_module_register(). Here is an example of how to
   store a configuration within the module file:
phpss_module_config_store("mymodule", array(
    "option1"         => "test",
    "option2"         => 14
));

   You can also store options in the central phpSecureSite config
   file (normally config/phpss.php). To do this, you create an
   array named $phpss_cfg["module"][<modulename>]. You put config
   values into this array, just as you would when calling
   phpss_module_set_config(), but you must also define two more
   values in the same array; enable, which is a boolean value
   defining whether the module should be loaded or not, and
   modulefile, which is the path to the module file which the
   configuration is for. Here is how the previous example would
   look when placed in the central configuration:
$phpss_cfg["module"]["mymodule"] = array(
        "enable"        => true,
        "modulefile"    => PHPSS_ROOT_FS . "/modules/mymodule.php",

        "option1"       => "test",
        "option2"       => 14
);

   The configuration can then be retreived (as an array) by
   calling phpss_module_get_config() with the name of the module
   as an argument, and an optional module type argument.

   You should also set a default config for your module. This is
   done by calling phpss_module_set_default_config(), and passing
   it the default configuration. This should usually be done
   around the time the module is being registered. It will define
   any options which are not set in the current configuration,
   but leave existing ones in place.
     _________________________________________________________

8.4. Storing temporary data

   phpSecureSite also provides functions for storing and
   retreiving temporary data. This may be useful for many things,
   most importantly to communicate between event hooks. Permanent
   or long-term (ie inter-request) data should be stored in the
   database.

   Temporary data is stored by calling phpss_module_set_data(),
   which takes the name of the module, the name of the data, the
   data itself and optionally the type of module (as usual). It
   supports all datatypes PHP supports.

   To fetch the data you call phpss_module_get_data(), which
   takes the name of the module, the name of the data and the
   optional module type as an argument.

   When you fetch data you can also fetch a reference to the
   data. This is very useful for example if you store an array
   and need to change a single value. References are explained in
   detail in the PHP docs, so we won't go to deep into it here,
   but here is a small example of how references can make your
   life easier:

$data = array("data1" => "abcd", "data2" => "efgh");
phpss_module_set_data("mymodule", "data", $data);

$dataref = &phpss_module_get_data("mymodule", "data");
$dataref["data1"] = "1234";

   After this, the data stored as "data" will look like
   array("data1" => "1234", "data2" => "efgh"). This is because
   instead of fetching a copy of the data, we get a reference to
   the data. We do this by putting an & before the
   phpss_module_get_data function call. When we have a reference
   to the data, any changes we do to the reference ($dataref in
   this example) will also affect the centrally stored data. This
   way we don't have to fetch a whole copy of the data, make the
   change and then store the whole array again. It is both much
   faster and more convenient.
     _________________________________________________________

8.5. The event system

   The event system is one of the two mechanisms used by modules
   to integrate with the core system, and it is mainly used by
   normal modules. The other method is handlers, which are
   discussed in the next section.

   During execution, phpSecureSite will trigger a set of events
   at certain places, for example when a user has successfully
   logged in. A list of these events is avilable in the Events
   reference. Modules can register hooks for these events, which
   are functions that are to be called when a specific event
   occurs. The functions are also passed a set of data which are
   related to the event.

   Event hooks can be named whatever you want, and they must take
   two arguments; the name of the event, and an array of data for
   the event. The hook must be registered by calling
   phpss_event_register_hook(), which takes the name of the event
   and the name of the hook function as arguments. An events
   hooks are called in the order they are registered. They can
   also return a value, but if they do then execution of the
   event will be aborted, and the return code will be returned to
   the caller. Usually the caller (for example phpss_login())
   will abort and further return the value. So normally the hook
   should not return a value.
     _________________________________________________________

8.6. Handlers

   Handlers are the other method modules use for integrating with
   the core system (the first being events). They are used by the
   special module types; database, authentication and log
   modules.

   A handler is a function which is given a specific task to
   handle, for example a database module needs to provide a
   function that connects to the database server. A list of the
   various handlers is available in the Handlers reference.

   To register a handler you call phpss_register_handler(),
   giving the type of handler and the name of the handler
   function as arguments. The arguments the handler must accept
   and its return value varies from handler type to handler type,
   so you need to have a look at the mentioned handler reference
   for more information.

   As the handlers are given rather critical tasks, a handler
   must be registered for every handler type or the system
   obviously will not work. Consequently, a module should
   register a function for all handler types which are related to
   the module type. For example, a database module must register
   functions for all the database handlers.
     _________________________________________________________

8.7. Using caches

   The cache subsystem handles temporary in-memory storage of
   data lookups, and is useful to prevent excessive use of the
   database backend. Module developers are encouraged to take
   extensive use of this.

   Each module gets its own cache space, in which it can create
   separate caches for various purposes. Usually you want to have
   one cache per type of data. The data values are stored with a
   key, which is used to look up the value in the cache. The
   cache can store all datatypes supported by php.

   The various cache functions are described in the Cache
   function reference. Usually you will only need three
   functions: phpss_cache_set(), phpss_cache_get() and
   phpss_cache_clear(). All functions take the module name on
   optionally the module type. You may also need to specify a
   cache name, which is used to distinguish the various caches
   your module uses.

   Let us take a look at an example. Let us say you need two
   functions, store_data() and get_data(). To make these
   functions use the cache, they would be implemented like this:

function store_data($key, $value) {
        phpss_db_query("INSERT INTO mytable (id, data) VALUES ('$key',
'$value')");
        phpss_cache_set("mymodule", "data", $key, $value);
}

function get_data($key) {
        $data = phpss_cache_get("mymodule", "data", $key);

        if ($data == PHPSS_CACHE_NOTFOUND) {
                $rs = phpss_db_query("SELECT data FROM mytable WHERE id
 = '$key'");
                $data = (sizeof($rs) > 0 ? $rs[0][0] : false);

                phpss_cache_set("mymodule", "data", $key, $value);
        }

        return $data;
}

   As you see in get_data(), we use the PHPSS_CACHE_NOTFOUND
   constant to check if a value was found in the cache. If it was
   not found, we fetch the data from the database.

   Even if you do not need to use the cache system in your own
   module, you may want to use phpss_cache_clear(). This is used
   to clear a cache. If you need to change some data directly in
   the phpSecureSite database, you must make sure that an old,
   cached copy of the data is not used in a later lookup. For
   example, to clear the session data cache in the core, you
   would call this code:

phpss_cache_clear("phpss", PHPSS_CACHE_SESSIONDATA, PHPSS_MODULE_CORE);

   Here we send PHPSS_CACHE_SESSIONDATA as the cache name
   identifier, all the core system caches have identifiers like
   this. A list of these can be found in the Cache stores
   constant reference.
     _________________________________________________________

8.8. Logging and error reporting

   phpSecureSite includes a log subsystem, and for it to be of
   any use all events of interest to the developer or system
   administrator needs to be logged.

   The log system can find most of the information that goes into
   a log entry for itself, you just need to say where the message
   came from (the module name), the severity of the event and the
   log message itself. You generate a log entry by calling
   phpss_log(), and passing the following arguments: name of your
   module, the message class (or severity), the log message, and
   optionally any extra information and the type of module
   (defaults to a normal module). A list of log classes can be
   found in the Log classes reference.

   Whenever an error occurs you should call phpss_error(). This
   will display an error message to the user and abort script
   execution, as well as log the error. The function takes four
   arguments: the name of the module which generated the error,
   the error message, and optionally any extra info and the type
   of module (defaults to a normal module).

   You may notice that you can provide both an error message and
   some extra error information. The error message itself will be
   displayed to the user whenever something goes wrong, and so it
   should not be very detailed so that information about the
   system is made available. This is why you can give some extra
   information, which will normally not be displayed to the user.
   The extra information will only be displayed if the system has
   been configured to display additional information about error
   messages, and it will also be part of the log entry for the
   error.
     _________________________________________________________

Chapter 9. Reference

9.1. Functions

   This is a list of functions provided by phpSecureSite or the
   modules distributed with it. Note that the list only includes
   functions which are meant to be used by application developers
   or module developers, functions used internally by
   phpSecureSite are not listed.

   All functions whose names are prefixed with & can return a
   reference to the data, as well as a copy of it. See the php
   docs for more info on references.
     _________________________________________________________

9.1.1. Authentication and account/group data

   phpss/func/auth.php

   Functions for user authentication and account/group data
   retreival. All usernames, group names and passwords are
   case-sensitive.

   int phpss_authenticate( str username, str password );

          Authenticates a user - returns a positive account id on
          success, or false if the provided username/password is
          wrong

   str phpss_encrypt_password( str password[, str algorithm] );

          Encrypts the password for comparison with password
          stored in the authentication backend. Valid algorithms
          can be found in the authentication config description,
          if algorithm is not defined the configured one will be
          used.

   arr phpss_get_account_data( int accountid );

          Returns the id, username and password of an account as
          an array, or false if the account doesn't exist

   arr phpss_get_account_groups( int accountid );

          Returns an array with ids of groups that an account is
          a member of. If the account doesn't exist, an empty
          array will be returned.

   int phpss_get_account_id( str username );

          Returns the account id of a username, or false if the
          username doesn't exist.

   arr phpss_get_group_data( int groupid );

          Returns the id and name of a group, or false if the
          group doesn't exist

   int phpss_get_group_id( str groupname );

          Returns the id of a group based on the group name, or
          false if the group doesn't exist
     _________________________________________________________

9.1.2. Database

   phpss/func/database.php

   Database-related functions, these are mainly wrappers for the
   database handlers.

   str phpss_db_escape_string( str string );

          Returns the string with quotes and special chars
          escaped, so it is safe to place in a database query

   arr phpss_db_query( str query );

          Executes a database query. The result set is returned
          as a matrix (a two-dimensional array), with a numeric
          row index as the first element, and a numeric column
          index as the second. If the query fails to execute,
          phpSecureSite will exit with an error
     _________________________________________________________

9.1.3. Cache

   phpss/func/cache.php

   Functions for using data caches. These are useful for
   temporarily storing data when looked up in a database, in
   order to avoid subsequent requests for the data resulting in
   another database lookup.

   All functions take a module name and type, so each module has
   its own cache store. In addition, you need to pass a cache
   name, so that you can have separate caches for different types
   of data.

   void phpss_cache_clear( str module, str cachename[, str
          moduletype ] );

          Empties a cache. Useful when you need to be sure the
          data you fetch is fresh from the database.

   void phpss_cache_delete( str module, str cachename mixed key[,
          str moduletype ] );

          Removes an entry from the cache.

   bool phpss_cache_enabled( );

          Checks if the cache system is enabled or not, mostly
          for internal use.

   bool phpss_cache_exists( str module, str cachename mixed key[,
          str moduletype ] );

          Checks if an entry exists in the database.

   mixed phpss_cache_get( str module, str cachename mixed key[,
          str moduletype ] );

          Fetches an entry from a cache.

   arr &phpss_cache_get_struct( str module[, str moduletype ] );

          Fetches the complete cache structure for a module,
          mostly for internal use.

   mixed phpss_cache_search( str module, str cachename, mixed
          value[, str moduletype ] );

          Searches a cache for a value, and returns the
          corresponding key. Only works for scalar (ie numerical
          / string) values.

   void phpss_cache_set( str module, str cachename, mixed key,
          mixed value[, str moduletype ] );

          Stores a value in the cache, may be any data type.
     _________________________________________________________

9.1.4. Event

   phpss/func/event.php

   Event-related functions. Handler functions are also described
   here, although they are not strictly part of the event system
   they are somewhat related.

   void phpss_event_register_hook( str event, str hook );

          Registers an event hook, the hook parameter is the name
          of the hook function. Hooks will be called in the
          registered order when the event is emitted.

   str &phpss_get_handler( str handlertype );

          Returns the name of the function which is registered as
          a handler

   void phpss_register handler( str handlertype, str function );

          Registers a handler function
     _________________________________________________________

9.1.5. Logging

   phpss/func/log.php

   Functions that are part of, or relevant to, the log system.

   void phpss_error( str module, str error[, str info[, str
          type]] );

          Prints an error message and exits. Info is any extra
          info which may help in solving the problem, and type is
          the type of module (defaults to a normal module)

   void phpss_log( str module, int class, str message[, str
          info[, str type]] );

          Sends a message to the log subsystem. Class is the
          message class, info is any extra info and type is the
          module type

   str phpss_log_class_name( int class );

          Returns the name of a log class, or false if the class
          doesn't exist
     _________________________________________________________

9.1.6. Main control functions

   phpss/func/main.php

   These functions are the main, top-level functions of
   phpSecureSite.

   str phpss_login( str username, str password );

          Authenticates a user, and sets up a session if
          successful. The returned string indicates the action
          which should be taken. The return values are:

        phpss_login_allow
                The user successfully logged in.

        phpss_login_authfail
                The client supplied a wrong username/password
                combination.

        phpss_login_bruteforce_accountlock
                The account has been locked for logins because of
                too many failed logins. Requires the bruteforce
                (bruteforce attack protection) module.

        phpss_login_bruteforce_iplock
                Logins from this IP address have been denied
                because of too many failed logins. Requires the
                bruteforce (bruteforce attack protection) module.

        phpss_login_ipaccess_deny
                Logins from the source IP address are denied by
                the ipaccess (client ip access control) module.

   void phpss_logout( );

          Destroys the current users session.

   str phpss_validate( );

          Validates the current session. It is the main function
          of phpSecureSite, and protects the pages in the
          application from unauthorized users. The return value
          is a string indicating the action to be taken, possible
          values are:

        phpss_validate_acl_deny
                Access is denied by an acl (access control list).
                Requires the acl (access control lists) module.

        phpss_validate_allow
                The session is successfully validated, and the
                user is allowed access.

        phpss_validate_hijack_fail
                The client's IP address has changed since the
                session was created. May be a session hijack
                attempt. Requires the hijack (session hijacking
                countermeasures) module.

        phpss_validate_ipaccess_deny
                Access from the source IP address is denied by
                the ipaccess (client ip access control) module.

        phpss_validate_nosession
                The user either didn't have a session cookie, or
                the session key was invalid,

        phpss_validate_timeout_fail
                The session has timed out (idled for too long),
                and the user must log in again to gain access.
                Requires the timeout (session timeouts) module.
     _________________________________________________________

9.1.7. Miscellaneous

   phpss/func/misc.php

   str phpss_get_ip( int id );

          Looks up an IP address in the database, based on its
          database ID.

   int phpss_get_ip_id( str ip[, bool autoreg] );

          Returns the database id of an IP address. ip is the IP
          address in dotted-decimal form. If autoreg is true
          (default), the IP address will be registered if it
          doesn't exist.
     _________________________________________________________

9.1.8. Module

   phpss/func/module.php

   Module-related functions. All type parameters refer to the
   type of module, and defaults to PHPSS_MODULE_NORMAL.

   arr &phpss_module_get_config( str module[, str type ] );

          Retrieves a modules configuration as an array

   mixed &phpss_module_get_data( str module, str name[, str type]
          );

          Retreives a data variable for a module. name is the
          name of the data variable you want to fetch. If the
          variable doesn't exist, it will return false.

   void phpss_module_register( str module[, str type] );

          Registers a module.

   void phpss_module_set_config( str module, arr config[, int
          type ] );

          Stores a configuration for a module. The configuration
          should be an array of key/value pairs, Any existing
          config will be overwritten,

   void phpss_module_set_data( str module, str name, mixed data[,
          int type ] );

          Stores a data variable for a module.

   void phpss_module_set_default_config( str module, arr config[,
          int type ] );

          Sets a default config for a module. Usually called when
          the module is loaded. It sets options which are not
          defined in the existing config, but leaves existing
          ones in place.
     _________________________________________________________

9.1.9. Session

   Session-related functions.

   str phpss_fetch_sessionkey( );

          Retreives the session key from the cookie. Returns
          false if the cookie doesn't exist.

   arr phpss_get_session_data( str sessionkey );

          Retreives the id, sessionkey, accountid, ipid, created,
          lastrequest and active data about a session as an
          associative array, or false if the session doesn't
          exist.
     _________________________________________________________

9.1.10. acl module (access control list)

   These functions are provided by the acl (access control lists)
   module. Valid access definitions are allow and deny.

   str phpss_acl_get_account_access( int accountid );

          Returns the access for an account.

   str phpss_acl_get_group_access( int groupid );

          Returns the access for a group.

   str phpss_acl_get_group_access_multiple( arr groups );

          Returns the access for a set of groups. Will apply the
          preferred access if the groups have conflicting rules.
          Expects an array of group ids.

   str phpss_acl_get_policy( void );

          Returns the current access policy.

   str phpss_acl_get_preferred( void );

          Returns the preferred access.

   void phpss_acl_set_account_access( int accountid, int access
          );

          Sets an access rule for an account.

   void phpss_acl_set_group_access( int groupid, int access );

          Sets an access rule for a group.

   void phpss_acl_set_policy( int access );

          Sets the access policy.

   void phpss_acl_set_preferred( int access );

          Sets the preferred access for users who have
          conflicting group access rules.
     _________________________________________________________

9.1.11. svars module (session variables)

   These functions are provided by the svars (session variables)
   module.

   bool phpss_svars_exists( str name[, bool ignorecache] );

          Checks if a session variable has been registered. name
          is the name of the variable, and the optional
          ignorecache argument which causes the cache to be
          bypassed. Returns true if the variable is set, and
          false if not.

   mixed phpss_svars_get( str name );

          Retrieves a session variable for the current session.
          name is the name of the session variable. If the
          variable does not exist it will return blank ("").

   void phpss_svars_set( str name, mixed data );

          Defines a session variable for the current session.
          name is the name of the session variable to create, and
          data is the value. data can be of any datatype
          supported by PHP except resource types. If a session
          variable with the same name already exists it will be
          overwritten.

          If the config option autoset is enabled, the session
          variable will automatically be set in the $phpss_svars
          array in the global scope when this function is called.
     _________________________________________________________

9.2. Constants

   Constants are used throughout phpSecureSite as identifiers for
   various purposes. Always use the constant, and not its value,
   as the actual value may change in later versions.

   The constants used as event and handler identifiers are
   available in the Events and Handlers setions.
     _________________________________________________________

9.2.1. Module types

   Most module-related functions expect to be passed a module
   type identifier, which are contained in these constants. All
   module types default to PHPSS_MODULE_NORMAL.

   PHPSS_MODULE_AUTH
          Authentication module, for authentication and account
          data lookups in a backend system.

   PHPSS_MODULE_CORE
          Used for the phpSecureSite core, and should not be used
          by anything else.

   PHPSS_MODULE_DATABASE
          Database module, for communication with a database
          server.

   PHPSS_MODULE_LOG
          Log module, writes log entries to a destination.

   PHPSS_MODULE_NORMAL
          Used for normal modules, and the default module type
          for most functions.

   PHPSS_MODULE_TOOL
          Stand-alone tool which works against the phpSecureSite
          API.
     _________________________________________________________

9.2.2. Log classes

   Log classes are used to specify the severity of messages
   passed to the logging subsystem through phpss_log().

   PHPSS_LOG_INFO
          An informational message, such as users logging in/out

   PHPSS_LOG_NOTICE
          A normal, but significant, message - for example when a
          login is denied, or the database is cleaned

   PHPSS_LOG_WARNING
          A warning, or severe message - like when a session
          hijack attempt is detected.

   PHPSS_LOG_ERROR
          An error. This class is used by phpss_error() to log
          any error messages it receives, and should not be used
          anywhere else. Pass any and all errors to
          phpss_error().
     _________________________________________________________

9.2.3. Cache stores

   Constants identifying various caches in the core system, as
   well as other cache-related constants.

   PHPSS_CACHE_NOTFOUND
          This is a special value returned by the cache lookup
          functions when an entry is not found.

   PHPSS_CACHE_ACCOUNTDATA
          Account data cache.

   PHPSS_CACHE_ACCOUNTGROUPS
          Account group list cache.

   PHPSS_CACHE_ACCOUNTID
          Account id lookup cache.

   PHPSS_CACHE_GROUPDATA
          Group data cache.

   PHPSS_CACHE_GROUPID
          Group id lookup cache.

   PHPSS_CACHE_IPID
          IP address id lookup cache.

   PHPSS_CACHE_SESSIONDATA
          Session data cache.
     _________________________________________________________

9.2.4. Miscellaneous

   Miscellaneous constants.

   PHPSS_CONFIGFILE
          This can be used to specify which file to load the
          configuration from. It must be defined before
          phpSecureSite is loaded.

   PHPSS_NOINIT
          Disables phpSecureSite initialization when loaded.
          Mostly useful for tools which need to load
          phpSecureSite without initializing it.

   PHPSS_ROOT_FS
          This specifies the path to the filesystem root
          directory where phpSecureSite is located. It is used
          for loading modules and function libraries.
     _________________________________________________________

9.3. Events

   Events are emitted at certain places during phpSecureSite
   execution. Modules can register hook functions for these
   events, to be called whenever the event occurs. This is the
   primary mechanism for interaction between modules and the core
   system. More information on events is available in the The
   event system section.

   Events are sorted by the order in which the are emitted, and
   grouped by their context.
     _________________________________________________________

9.3.1. System-related events

   Event Data Description
   PHPSS_EVENT_SYSTEM_INIT   System is initialized (database link
   opened, modules loaded etc)
   PHPSS_EVENT_SYSTEM_DBCLEAN sessions Database is being cleaned
   PHPSS_EVENT_SYSTEM_SHUTDOWN   Script execution is completed.
   Called after PHP has flushed output buffers, so no output is
   possible
     _________________________________________________________

9.3.2. Session creation, phpss_login()

   Event Data Description
   PHPSS_EVENT_LOGIN_PRE username, password Start of login
   process
   PHPSS_EVENT_LOGIN_AUTH accountid, username, password User has
   been authenticated, but the session has not been created
   PHPSS_EVENT_LOGIN_FAIL username, password Authentication
   failed, or a PHPSS_EVENT_LOGIN_AUTH hook failed
   PHPSS_EVENT_LOGIN_SUCCESS accountid Session has been created
     _________________________________________________________

9.3.3. Session validation, phpss_validate()

   Event Data Description
   PHPSS_EVENT_VALIDATE_PRE sessionkey Start of session
   validation
   PHPSS_EVENT_VALIDATE_CHECK sessionkey Session validation check
   was successful, but session is not updated yet
   PHPSS_EVENT_VALIDATE_FAIL   Session validation failed, or a
   PHPSS_EVENT_VALIDATE_CHECK hook failed
   PHPSS_EVENT_VALIDATE_SUCCESS sessionkey Session is validated
     _________________________________________________________

9.3.4. Session closing, phpss_logout()

   Event                   Data       Description
   PHPSS_EVENT_LOGOUT_PRE  sessionkey Start of logout process
   PHPSS_EVENT_LOGOUT_POST sessionkey Session har been destroyed
     _________________________________________________________

9.4. Handlers

   Handlers are used by all special modules (ie not normal
   modules). A handler is a function which is to be used for a
   specific task. More information is available in the Handlers
   section.
     _________________________________________________________

9.4.1. Authentication handlers

   These handlers are provided by auth modules, and take care of
   authentication-related tasks, including account/group data
   lookups.

   Type Parameters Returns Description
   PHPSS_HANDLER_AUTH_ACCOUNTDATA accountid array(id, username,
   password), or false if invalid account Fetches account data
   PHPSS_HANDLER_AUTH_ACCOUNTGROUPS accountid Array of group ids
   Fetches groups that an account is a member of
   PHPSS_HANDLER_AUTH_ACCOUNTID username accountid Looks up
   account id based on username
   PHPSS_HANDLER_AUTH_AUTHENTICATE username, password accountid,
   or false if wrong Authenticates a user
   PHPSS_HANDLER_AUTH_GROUPDATA groupid array(id, name) Fetches
   data for a group, or false if not found
   PHPSS_HANDLER_AUTH_GROUPID groupname groupid Looks up group id
   from group name
     _________________________________________________________

9.4.2. Database handlers

   Database handlers are provided by database modules, and
   handles database-related tasks.

   Type Parameters Returns Description
   PHPSS_HANDLER_DB_CLOSE     Closes the database link
   PHPSS_HANDLER_DB_CONNECT     Connects to the database
   PHPSS_HANDLER_DB_ESCAPESTRING string escapedstring Escapes
   special chars so the string is safe to put in a query
   PHPSS_HANDLER_DB_QUERY query array[row][column] Executes a
   query, returns a matrix
     _________________________________________________________

9.4.3. Log handlers

   Log handlers are provided by log modules, and handles various
   log tasks.

   Type Parameters Returns Description
   PHPSS_HANDLER_LOG_MESSAGE module, moduletype, class, date,
   sessionkey, ip, uri, message, info   Writes a message to the
   log
     _________________________________________________________

9.5. Database structure

   This is a complete description of the phpSecureSite database.
   A big problem with the database design is that because
   phpSecureSite is designed to work on several different
   database servers use of special server-specific features must
   be avoided.

   The column types used can mean different things on different
   database servers, so a definition of the various column types
   is in order. All times and dates are stored as ints in UNIX
   timestamp format and boolean values are also stored as ints -
   this is for database portability.

   Column type definitions

   tinyint
          A one-byte signed integer

   smallint
          A two-byte signed integer

   int
          A four-byte signed integer

   char
          A fixed-width case-sensitive character string

   varchar
          A variable-width case-sensitive character string

   text
          A large text string, should be able to store megabytes
          of data.

   phpSecureSite tables

   phpss_account
          Contains account information.

   Column name Type Index Null Default Description
   id int primary key, auto-increment no   Unique account id
   username varchar(255) unique no   Account username
   password varchar(255)   no   Account password (hashed)
   active tinyint   no 1 Account state (active or not)

   phpss_account_group
          This table is a so-called link-table between account
          and group, meaning it defines which accounts are
          members of which groups.

          Column name Type     Index       Null Default Description
          accountfid  int      primary key no           Account ID link
          groupfid    smallint primary key no           Group ID link

   phpss_bruteforce_account_fail
          Stores failed account login attempts for the bruteforce
          (bruteforce attack protection) module.

     Column name Type Index Null Default Description
     accountfid  int  index no           Account for which login failed
     time        int        no           Timestamp of fail

   phpss_bruteforce_account_lock
          Stores account locks for the bruteforce (bruteforce
          attack protection) module.

     Column name Type Index Null Default Description
     accountfid  int  index no           Account which is locked
     time        int        no           Timestamp when lock was placed

   phpss_bruteforce_ip_fail
          Stores failed ip login attempts for the bruteforce
          (bruteforce attack protection) module.

  Column name Type Index Null Default Description
  ipfid       int  index no           IP address for which login failed
  time        int        no           Timestamp of fail

   phpss_bruteforce_ip_lock
          Stores IP address locks for the bruteforce (bruteforce
          attack protection) module.

     Column name Type Index Null Default Description
     ipfid       int  index no           IP address of lock
     time        int        no           Timestamp when lock was placed

   phpss_group
          Information about account groups.

   Column name Type Index Null Default Description
   id smallint primary key, auto-increment no   Group ID
   name varchar(255) unique no   Group name

   phpss_ip
          Stores IP addresses

   Column name Type Index Null Default Description
   id int primary key, auto-increment no   IP address ID
   ip varchar(15) unique no   IP address, dotted decimal

   phpss_ipaccess
          Access rules for the ipaccess (client ip access
          control) module.

   Column name Type Index Null Default Description
   ip varchar(15) primary key no   IP address, dotted decimal
   access tinyint   no   Access definition (true/false)

   phpss_ipaccess_account
          Account access rules for the ipaccess (client ip access
          control) module.

   Column name Type Index Null Default Description
   ip varchar(15) primary key no   IP address, dotted decimal
   accountfid int primary key no   Account ID link
   access tinyint   no   Access definition (true/false)

   phpss_ipaccess_group
          Group access rules for the ipaccess (client ip access
          control) module.

   Column name Type Index Null Default Description
   ip varchar(15) primary key no   IP address, dotted decimal
   groupfid smallint primary key no   Group ID link
   access tinyint   no   Access definition (true/false)

   phpss_log
          The system log, entries stored by the database module.

   Column name Type Index Null Default Description
   time int   no   Timestamp for entry
   class varchar(8)   no   Entry class
   sessionfid int   yes   Session ID link
   accountfid int   yes   Account ID link
   ipfid int   no   IP address ID link
   uri varchar(255)   no   URI of file which generated entry
   module varchar(64)   no   Module which sent entry
   moduletype varchar(8)   no   Type of module
   message varchar(255)   no   The log message itself
   info varchar(255)   no   Any extra info

   phpss_session
          All session information is stored here, and so it is
          the central table in the database.

   Column name Type Index Null Default Description
   id int primary key, auto-increment no   Session ID
   sessionkey char(32) unique no   Session key
   accountfid int   yes   Session owner. account ID link
   ipfid int   no   IP address ID link, which created session
   created int   no   Timestamp of session creation
   lastrequest int   no   Timestamp of last request
   active tinyint   no   Session status (true/false)

   phpss_svars
          Session variables for the svars (session variables)
          module.

   Column name Type Index Null Default Description
   sessionfid int primary key no   Session ID link
   name varchar(255) primary key no   Variable name
   data text   no   Variable data (serialized)

   phpss_usertrack_req
          Contains request records for the usertrack (page
          request tracking) module.

   Column name Type Index Null Default Description
   id int primary key, auto-increment no   Request ID
   sessionfid int   no   Session ID link
   accountfid int   no   Account ID link
   time int   no   Timestamp of request
   usertrack_urlfid int   no   URL ID link

   phpss_usertrack_url
          URLs entries for the usertrack (page request tracking)
          module.

   Column name Type Index Null Default Description
   id int primary key, auto increment no   URL ID
   url varchar(255) index no   URL
     _________________________________________________________

Appendix A. Project information

   The phpSecureSite project was started in the fall of 2001 by
   Erik Grinaker. The goal is to create a full-featured
   authentication and session-handling framework for
   web-developers.

   The project web site is located at
   http://oss.wired-networks.net/phpsecuresite/.

   Project developers
     * Erik Grinaker <erikg@wired-networks.net> (maintainer)

   Contributors
     * Dave Rich
     * Mike Hore
     * Erich "Ricky" Iseli
     _________________________________________________________

Appendix B. Related articles and documents

   This is a list of articles and documents about web-application
   security, which may be of interest.

     * The PHP manual security chapter
     * ONLamp PHP Security part 1, part 2 and part 3
     * Securing PHP: Step-by-step
     _________________________________________________________

Appendix C. GNU General Public Licence, version 2

GNU General Public License (GPL)

   Version 2, June 1991

   Copyright (C) 1989, 1991 Free Software Foundation, Inc. 59
   Temple Place, Suite 330, Boston, MA 02111-1307 USA

   Everyone is permitted to copy and distribute verbatim copies
   of this license document, but changing it is not allowed.

   Preamble

   The licenses for most software are designed to take away your
   freedom to share and change it. By contrast, the GNU General
   Public License is intended to guarantee your freedom to share
   and change free software--to make sure the software is free
   for all its users. This General Public License applies to most
   of the Free Software Foundation's software and to any other
   program whose authors commit to using it. (Some other Free
   Software Foundation software is covered by the GNU Library
   General Public License instead.) You can apply it to your
   programs, too.

   When we speak of free software, we are referring to freedom,
   not price. Our General Public Licenses are designed to make
   sure that you have the freedom to distribute copies of free
   software (and charge for this service if you wish), that you
   receive source code or can get it if you want it, that you can
   change the software or use pieces of it in new free programs;
   and that you know you can do these things.

   To protect your rights, we need to make restrictions that
   forbid anyone to deny you these rights or to ask you to
   surrender the rights. These restrictions translate to certain
   responsibilities for you if you distribute copies of the
   software, or if you modify it.

   For example, if you distribute copies of such a program,
   whether gratis or for a fee, you must give the recipients all
   the rights that you have. You must make sure that they, too,
   receive or can get the source code. And you must show them
   these terms so they know their rights.

   We protect your rights with two steps: (1) copyright the
   software, and (2) offer you this license which gives you legal
   permission to copy, distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make
   certain that everyone understands that there is no warranty
   for this free software. If the software is modified by someone
   else and passed on, we want its recipients to know that what
   they have is not the original, so that any problems introduced
   by others will not reflect on the original authors'
   reputations.

   Finally, any free program is threatened constantly by software
   patents. We wish to avoid the danger that redistributors of a
   free program will individually obtain patent licenses, in
   effect making the program proprietary. To prevent this, we
   have made it clear that any patent must be licensed for
   everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
   modification follow.

   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND
   MODIFICATION

   0. This License applies to any program or other work which
   contains a notice placed by the copyright holder saying it may
   be distributed under the terms of this General Public License.
   The "Program", below, refers to any such program or work, and
   a "work based on the Program" means either the Program or any
   derivative work under copyright law: that is to say, a work
   containing the Program or a portion of it, either verbatim or
   with modifications and/or translated into another language.
   (Hereinafter, translation is included without limitation in
   the term "modification".) Each licensee is addressed as "you".

   Activities other than copying, distribution and modification
   are not covered by this License; they are outside its scope.
   The act of running the Program is not restricted, and the
   output from the Program is covered only if its contents
   constitute a work based on the Program (independent of having
   been made by running the Program). Whether that is true
   depends on what the Program does.

   1. You may copy and distribute verbatim copies of the
   Program's source code as you receive it, in any medium,
   provided that you conspicuously and appropriately publish on
   each copy an appropriate copyright notice and disclaimer of
   warranty; keep intact all the notices that refer to this
   License and to the absence of any warranty; and give any other
   recipients of the Program a copy of this License along with
   the Program.

   You may charge a fee for the physical act of transferring a
   copy, and you may at your option offer warranty protection in
   exchange for a fee.

   2. You may modify your copy or copies of the Program or any
   portion of it, thus forming a work based on the Program, and
   copy and distribute such modifications or work under the terms
   of Section 1 above, provided that you also meet all of these
   conditions:

     a) You must cause the modified files to carry prominent
     notices stating that you changed the files and the date of
     any change.

     b) You must cause any work that you distribute or publish,
     that in whole or in part contains or is derived from the
     Program or any part thereof, to be licensed as a whole at
     no charge to all third parties under the terms of this
     License.

     c) If the modified program normally reads commands
     interactively when run, you must cause it, when started
     running for such interactive use in the most ordinary way,
     to print or display an announcement including an
     appropriate copyright notice and a notice that there is no
     warranty (or else, saying that you provide a warranty) and
     that users may redistribute the program under these
     conditions, and telling the user how to view a copy of this
     License. (Exception: if the Program itself is interactive
     but does not normally print such an announcement, your work
     based on the Program is not required to print an
     announcement.)

   These requirements apply to the modified work as a whole. If
   identifiable sections of that work are not derived from the
   Program, and can be reasonably considered independent and
   separate works in themselves, then this License, and its
   terms, do not apply to those sections when you distribute them
   as separate works. But when you distribute the same sections
   as part of a whole which is a work based on the Program, the
   distribution of the whole must be on the terms of this
   License, whose permissions for other licensees extend to the
   entire whole, and thus to each and every part regardless of
   who wrote it.

   Thus, it is not the intent of this section to claim rights or
   contest your rights to work written entirely by you; rather,
   the intent is to exercise the right to control the
   distribution of derivative or collective works based on the
   Program.

   In addition, mere aggregation of another work not based on the
   Program with the Program (or with a work based on the Program)
   on a volume of a storage or distribution medium does not bring
   the other work under the scope of this License.

   3. You may copy and distribute the Program (or a work based on
   it, under Section 2) in object code or executable form under
   the terms of Sections 1 and 2 above provided that you also do
   one of the following:

     a) Accompany it with the complete corresponding
     machine-readable source code, which must be distributed
     under the terms of Sections 1 and 2 above on a medium
     customarily used for software interchange; or,

     b) Accompany it with a written offer, valid for at least
     three years, to give any third party, for a charge no more
     than your cost of physically performing source
     distribution, a complete machine-readable copy of the
     corresponding source code, to be distributed under the
     terms of Sections 1 and 2 above on a medium customarily
     used for software interchange; or,

     c) Accompany it with the information you received as to the
     offer to distribute corresponding source code. (This
     alternative is allowed only for noncommercial distribution
     and only if you received the program in object code or
     executable form with such an offer, in accord with
     Subsection b above.)

   The source code for a work means the preferred form of the
   work for making modifications to it. For an executable work,
   complete source code means all the source code for all modules
   it contains, plus any associated interface definition files,
   plus the scripts used to control compilation and installation
   of the executable. However, as a special exception, the source
   code distributed need not include anything that is normally
   distributed (in either source or binary form) with the major
   components (compiler, kernel, and so on) of the operating
   system on which the executable runs, unless that component
   itself accompanies the executable.

   If distribution of executable or object code is made by
   offering access to copy from a designated place, then offering
   equivalent access to copy the source code from the same place
   counts as distribution of the source code, even though third
   parties are not compelled to copy the source along with the
   object code.

   4. You may not copy, modify, sublicense, or distribute the
   Program except as expressly provided under this License. Any
   attempt otherwise to copy, modify, sublicense or distribute
   the Program is void, and will automatically terminate your
   rights under this License. However, parties who have received
   copies, or rights, from you under this License will not have
   their licenses terminated so long as such parties remain in
   full compliance.

   5. You are not required to accept this License, since you have
   not signed it. However, nothing else grants you permission to
   modify or distribute the Program or its derivative works.
   These actions are prohibited by law if you do not accept this
   License. Therefore, by modifying or distributing the Program
   (or any work based on the Program), you indicate your
   acceptance of this License to do so, and all its terms and
   conditions for copying, distributing or modifying the Program
   or works based on it.

   6. Each time you redistribute the Program (or any work based
   on the Program), the recipient automatically receives a
   license from the original licensor to copy, distribute or
   modify the Program subject to these terms and conditions. You
   may not impose any further restrictions on the recipients'
   exercise of the rights granted herein. You are not responsible
   for enforcing compliance by third parties to this License.

   7. If, as a consequence of a court judgment or allegation of
   patent infringement or for any other reason (not limited to
   patent issues), conditions are imposed on you (whether by
   court order, agreement or otherwise) that contradict the
   conditions of this License, they do not excuse you from the
   conditions of this License. If you cannot distribute so as to
   satisfy simultaneously your obligations under this License and
   any other pertinent obligations, then as a consequence you may
   not distribute the Program at all. For example, if a patent
   license would not permit royalty-free redistribution of the
   Program by all those who receive copies directly or indirectly
   through you, then the only way you could satisfy both it and
   this License would be to refrain entirely from distribution of
   the Program.

   If any portion of this section is held invalid or
   unenforceable under any particular circumstance, the balance
   of the section is intended to apply and the section as a whole
   is intended to apply in other circumstances.

   It is not the purpose of this section to induce you to
   infringe any patents or other property right claims or to
   contest validity of any such claims; this section has the sole
   purpose of protecting the integrity of the free software
   distribution system, which is implemented by public license
   practices. Many people have made generous contributions to the
   wide range of software distributed through that system in
   reliance on consistent application of that system; it is up to
   the author/donor to decide if he or she is willing to
   distribute software through any other system and a licensee
   cannot impose that choice.

   This section is intended to make thoroughly clear what is
   believed to be a consequence of the rest of this License.

   8. If the distribution and/or use of the Program is restricted
   in certain countries either by patents or by copyrighted
   interfaces, the original copyright holder who places the
   Program under this License may add an explicit geographical
   distribution limitation excluding those countries, so that
   distribution is permitted only in or among countries not thus
   excluded. In such case, this License incorporates the
   limitation as if written in the body of this License.

   9. The Free Software Foundation may publish revised and/or new
   versions of the General Public License from time to time. Such
   new versions will be similar in spirit to the present version,
   but may differ in detail to address new problems or concerns.

   Each version is given a distinguishing version number. If the
   Program specifies a version number of this License which
   applies to it and "any later version", you have the option of
   following the terms and conditions either of that version or
   of any later version published by the Free Software
   Foundation. If the Program does not specify a version number
   of this License, you may choose any version ever published by
   the Free Software Foundation.

   10. If you wish to incorporate parts of the Program into other
   free programs whose distribution conditions are different,
   write to the author to ask for permission. For software which
   is copyrighted by the Free Software Foundation, write to the
   Free Software Foundation; we sometimes make exceptions for
   this. Our decision will be guided by the two goals of
   preserving the free status of all derivatives of our free
   software and of promoting the sharing and reuse of software
   generally.

   NO WARRANTY

   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS
   NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
   APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
   COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS
   IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
   ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
   IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME
   THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO
   IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO
   MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE,
   BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
   INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
   INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO
   LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
   SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
   TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
   OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGES.

   END OF TERMS AND CONDITIONS
     _________________________________________________________

Appendix D. GNU Free Documentation License, version 1.2

GNU Free Documentation License

   Version 1.2, November 2002

   Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 59
   Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is
   permitted to copy and distribute verbatim copies of this
   license document, but changing it is not allowed.

0. PREAMBLE

   The purpose of this License is to make a manual, textbook, or
   other functional and useful document "free" in the sense of
   freedom: to assure everyone the effective freedom to copy and
   redistribute it, with or without modifying it, either
   commercially or noncommercially. Secondarily, this License
   preserves for the author and publisher a way to get credit for
   their work, while not being considered responsible for
   modifications made by others.

   This License is a kind of "copyleft", which means that
   derivative works of the document must themselves be free in
   the same sense. It complements the GNU General Public License,
   which is a copyleft license designed for free software.

   We have designed this License in order to use it for manuals
   for free software, because free software needs free
   documentation: a free program should come with manuals
   providing the same freedoms that the software does. But this
   License is not limited to software manuals; it can be used for
   any textual work, regardless of subject matter or whether it
   is published as a printed book. We recommend this License
   principally for works whose purpose is instruction or
   reference.

1. APPLICABILITY AND DEFINITIONS

   This License applies to any manual or other work, in any
   medium, that contains a notice placed by the copyright holder
   saying it can be distributed under the terms of this License.
   Such a notice grants a world-wide, royalty-free license,
   unlimited in duration, to use that work under the conditions
   stated herein. The "Document", below, refers to any such
   manual or work. Any member of the public is a licensee, and is
   addressed as "you". You accept the license if you copy, modify
   or distribute the work in a way requiring permission under
   copyright law.

   A "Modified Version" of the Document means any work containing
   the Document or a portion of it, either copied verbatim, or
   with modifications and/or translated into another language.

   A "Secondary Section" is a named appendix or a front-matter
   section of the Document that deals exclusively with the
   relationship of the publishers or authors of the Document to
   the Document's overall subject (or to related matters) and
   contains nothing that could fall directly within that overall
   subject. (Thus, if the Document is in part a textbook of
   mathematics, a Secondary Section may not explain any
   mathematics.) The relationship could be a matter of historical
   connection with the subject or with related matters, or of
   legal, commercial, philosophical, ethical or political
   position regarding them.

   The "Invariant Sections" are certain Secondary Sections whose
   titles are designated, as being those of Invariant Sections,
   in the notice that says that the Document is released under
   this License. If a section does not fit the above definition
   of Secondary then it is not allowed to be designated as
   Invariant. The Document may contain zero Invariant Sections.
   If the Document does not identify any Invariant Sections then
   there are none.

   The "Invariant Sections" are certain Secondary Sections whose
   titles are designated, as being those of Invariant Sections,
   in the notice that says that the Document is released under
   this License. If a section does not fit the above definition
   of Secondary then it is not allowed to be designated as
   Invariant. The Document may contain zero Invariant Sections.
   If the Document does not identify any Invariant Sections then
   there are none.

   The "Cover Texts" are certain short passages of text that are
   listed, as Front-Cover Texts or Back-Cover Texts, in the
   notice that says that the Document is released under this
   License. A Front-Cover Text may be at most 5 words, and a
   Back-Cover Text may be at most 25 words.

   A "Transparent" copy of the Document means a machine-readable
   copy, represented in a format whose specification is available
   to the general public, that is suitable for revising the
   document straightforwardly with generic text editors or (for
   images composed of pixels) generic paint programs or (for
   drawings) some widely available drawing editor, and that is
   suitable for input to text formatters or for automatic
   translation to a variety of formats suitable for input to text
   formatters. A copy made in an otherwise Transparent file
   format whose markup, or absence of markup, has been arranged
   to thwart or discourage subsequent modification by readers is
   not Transparent. An image format is not Transparent if used
   for any substantial amount of text. A copy that is not
   "Transparent" is called "Opaque".

   Examples of suitable formats for Transparent copies include
   plain ASCII without markup, Texinfo input format, LaTeX input
   format, SGML or XML using a publicly available DTD, and
   standard-conforming simple HTML, PostScript or PDF designed
   for human modification. Examples of transparent image formats
   include PNG, XCF and JPG. Opaque formats include proprietary
   formats that can be read and edited only by proprietary word
   processors, SGML or XML for which the DTD and/or processing
   tools are not generally available, and the machine-generated
   HTML, PostScript or PDF produced by some word processors for
   output purposes only.

   The "Title Page" means, for a printed book, the title page
   itself, plus such following pages as are needed to hold,
   legibly, the material this License requires to appear in the
   title page. For works in formats which do not have any title
   page as such, "Title Page" means the text near the most
   prominent appearance of the work's title, preceding the
   beginning of the body of the text.

   A section "Entitled XYZ" means a named subunit of the Document
   whose title either is precisely XYZ or contains XYZ in
   parentheses following text that translates XYZ in another
   language. (Here XYZ stands for a specific section name
   mentioned below, such as "Acknowledgements", "Dedications",
   "Endorsements", or "History".) To "Preserve the Title" of such
   a section when you modify the Document means that it remains a
   section "Entitled XYZ" according to this definition.

   The Document may include Warranty Disclaimers next to the
   notice which states that this License applies to the Document.
   These Warranty Disclaimers are considered to be included by
   reference in this License, but only as regards disclaiming
   warranties: any other implication that these Warranty
   Disclaimers may have is void and has no effect on the meaning
   of this License.

2. VERBATIM COPYING

   You may copy and distribute the Document in any medium, either
   commercially or noncommercially, provided that this License,
   the copyright notices, and the license notice saying this
   License applies to the Document are reproduced in all copies,
   and that you add no other conditions whatsoever to those of
   this License. You may not use technical measures to obstruct
   or control the reading or further copying of the copies you
   make or distribute. However, you may accept compensation in
   exchange for copies. If you distribute a large enough number
   of copies you must also follow the conditions in section 3.

   You may also lend copies, under the same conditions stated
   above, and you may publicly display copies.

3. COPYING IN QUANTITY

   If you publish printed copies (or copies in media that
   commonly have printed covers) of the Document, numbering more
   than 100, and the Document's license notice requires Cover
   Texts, you must enclose the copies in covers that carry,
   clearly and legibly, all these Cover Texts: Front-Cover Texts
   on the front cover, and Back-Cover Texts on the back cover.
   Both covers must also clearly and legibly identify you as the
   publisher of these copies. The front cover must present the
   full title with all words of the title equally prominent and
   visible. You may add other material on the covers in addition.
   Copying with changes limited to the covers, as long as they
   preserve the title of the Document and satisfy these
   conditions, can be treated as verbatim copying in other
   respects.

   If the required texts for either cover are too voluminous to
   fit legibly, you should put the first ones listed (as many as
   fit reasonably) on the actual cover, and continue the rest
   onto adjacent pages.

   If you publish or distribute Opaque copies of the Document
   numbering more than 100, you must either include a
   machine-readable Transparent copy along with each Opaque copy,
   or state in or with each Opaque copy a computer-network
   location from which the general network-using public has
   access to download using public-standard network protocols a
   complete Transparent copy of the Document, free of added
   material. If you use the latter option, you must take
   reasonably prudent steps, when you begin distribution of
   Opaque copies in quantity, to ensure that this Transparent
   copy will remain thus accessible at the stated location until
   at least one year after the last time you distribute an Opaque
   copy (directly or through your agents or retailers) of that
   edition to the public.

   It is requested, but not required, that you contact the
   authors of the Document well before redistributing any large
   number of copies, to give them a chance to provide you with an
   updated version of the Document.

4. MODIFICATIONS

   You may copy and distribute a Modified Version of the Document
   under the conditions of sections 2 and 3 above, provided that
   you release the Modified Version under precisely this License,
   with the Modified Version filling the role of the Document,
   thus licensing distribution and modification of the Modified
   Version to whoever possesses a copy of it. In addition, you
   must do these things in the Modified Version:

     * A. Use in the Title Page (and on the covers, if any) a
       title distinct from that of the Document, and from those
       of previous versions (which should, if there were any, be
       listed in the History section of the Document). You may
       use the same title as a previous version if the original
       publisher of that version gives permission.
     * B. List on the Title Page, as authors, one or more persons
       or entities responsible for authorship of the
       modifications in the Modified Version, together with at
       least five of the principal authors of the Document (all
       of its principal authors, if it has fewer than five),
       unless they release you from this requirement.
     * C. State on the Title page the name of the publisher of
       the Modified Version, as the publisher.
     * D. Preserve all the copyright notices of the Document.
     * E. Add an appropriate copyright notice for your
       modifications adjacent to the other copyright notices.
     * F. Include, immediately after the copyright notices, a
       license notice giving the public permission to use the
       Modified Version under the terms of this License, in the
       form shown in the Addendum below.
     * G. Preserve in that license notice the full lists of
       Invariant Sections and required Cover Texts given in the
       Document's license notice.
     * H. Include an unaltered copy of this License.
     * I. Preserve the section Entitled "History", Preserve its
       Title, and add to it an item stating at least the title,
       year, new authors, and publisher of the Modified Version
       as given on the Title Page. If there is no section
       Entitled "History" in the Document, create one stating the
       title, year, authors, and publisher of the Document as
       given on its Title Page, then add an item describing the
       Modified Version as stated in the previous sentence.
     * J. Preserve the network location, if any, given in the
       Document for public access to a Transparent copy of the
       Document, and likewise the network locations given in the
       Document for previous versions it was based on. These may
       be placed in the "History" section. You may omit a network
       location for a work that was published at least four years
       before the Document itself, or if the original publisher
       of the version it refers to gives permission.
     * K. For any section Entitled "Acknowledgements" or
       "Dedications", Preserve the Title of the section, and
       preserve in the section all the substance and tone of each
       of the contributor acknowledgements and/or dedications
       given therein.
     * L. Preserve all the Invariant Sections of the Document,
       unaltered in their text and in their titles. Section
       numbers or the equivalent are not considered part of the
       section titles.
     * M. Delete any section Entitled "Endorsements". Such a
       section may not be included in the Modified Version.
     * N. Do not retitle any existing section to be Entitled
       "Endorsements" or to conflict in title with any Invariant
       Section.
     * O. Preserve any Warranty Disclaimers.

   If the Modified Version includes new front-matter sections or
   appendices that qualify as Secondary Sections and contain no
   material copied from the Document, you may at your option
   designate some or all of these sections as invariant. To do
   this, add their titles to the list of Invariant Sections in
   the Modified Version's license notice. These titles must be
   distinct from any other section titles.

   You may add a section Entitled "Endorsements", provided it
   contains nothing but endorsements of your Modified Version by
   various parties--for example, statements of peer review or
   that the text has been approved by an organization as the
   authoritative definition of a standard.

   You may add a passage of up to five words as a Front-Cover
   Text, and a passage of up to 25 words as a Back-Cover Text, to
   the end of the list of Cover Texts in the Modified Version.
   Only one passage of Front-Cover Text and one of Back-Cover
   Text may be added by (or through arrangements made by) any one
   entity. If the Document already includes a cover text for the
   same cover, previously added by you or by arrangement made by
   the same entity you are acting on behalf of, you may not add
   another; but you may replace the old one, on explicit
   permission from the previous publisher that added the old one.

   The author(s) and publisher(s) of the Document do not by this
   License give permission to use their names for publicity for
   or to assert or imply endorsement of any Modified Version.

5. COMBINING DOCUMENTS

   You may combine the Document with other documents released
   under this License, under the terms defined in section 4 above
   for modified versions, provided that you include in the
   combination all of the Invariant Sections of all of the
   original documents, unmodified, and list them all as Invariant
   Sections of your combined work in its license notice, and that
   you preserve all their Warranty Disclaimers.

   The combined work need only contain one copy of this License,
   and multiple identical Invariant Sections may be replaced with
   a single copy. If there are multiple Invariant Sections with
   the same name but different contents, make the title of each
   such section unique by adding at the end of it, in
   parentheses, the name of the original author or publisher of
   that section if known, or else a unique number. Make the same
   adjustment to the section titles in the list of Invariant
   Sections in the license notice of the combined work.

   In the combination, you must combine any sections Entitled
   "History" in the various original documents, forming one
   section Entitled "History"; likewise combine any sections
   Entitled "Acknowledgements", and any sections Entitled
   "Dedications". You must delete all sections Entitled
   "Endorsements."

6. COLLECTIONS OF DOCUMENTS

   You may make a collection consisting of the Document and other
   documents released under this License, and replace the
   individual copies of this License in the various documents
   with a single copy that is included in the collection,
   provided that you follow the rules of this License for
   verbatim copying of each of the documents in all other
   respects.

   You may extract a single document from such a collection, and
   distribute it individually under this License, provided you
   insert a copy of this License into the extracted document, and
   follow this License in all other respects regarding verbatim
   copying of that document.

7. AGGREGATION WITH INDEPENDENT WORKS

   A compilation of the Document or its derivatives with other
   separate and independent documents or works, in or on a volume
   of a storage or distribution medium, is called an "aggregate"
   if the copyright resulting from the compilation is not used to
   limit the legal rights of the compilation's users beyond what
   the individual works permit. When the Document is included an
   aggregate, this License does not apply to the other works in
   the aggregate which are not themselves derivative works of the
   Document.

   If the Cover Text requirement of section 3 is applicable to
   these copies of the Document, then if the Document is less
   than one half of the entire aggregate, the Document's Cover
   Texts may be placed on covers that bracket the Document within
   the aggregate, or the electronic equivalent of covers if the
   Document is in electronic form. Otherwise they must appear on
   printed covers that bracket the whole aggregate.

8. TRANSLATION

   Translation is considered a kind of modification, so you may
   distribute translations of the Document under the terms of
   section 4. Replacing Invariant Sections with translations
   requires special permission from their copyright holders, but
   you may include translations of some or all Invariant Sections
   in addition to the original versions of these Invariant
   Sections. You may include a translation of this License, and
   all the license notices in the Document, and any Warrany
   Disclaimers, provided that you also include the original
   English version of this License and the original versions of
   those notices and disclaimers. In case of a disagreement
   between the translation and the original version of this
   License or a notice or disclaimer, the original version will
   prevail.

   If a section in the Document is Entitled "Acknowledgements",
   "Dedications", or "History", the requirement (section 4) to
   Preserve its Title (section 1) will typically require changing
   the actual title.

9. TERMINATION

   You may not copy, modify, sublicense, or distribute the
   Document except as expressly provided for under this License.
   Any other attempt to copy, modify, sublicense or distribute
   the Document is void, and will automatically terminate your
   rights under this License. However, parties who have received
   copies, or rights, from you under this License will not have
   their licenses terminated so long as such parties remain in
   full compliance.

10. FUTURE REVISIONS OF THIS LICENSE

   The Free Software Foundation may publish new, revised versions
   of the GNU Free Documentation License from time to time. Such
   new versions will be similar in spirit to the present version,
   but may differ in detail to address new problems or concerns.
   See http://www.gnu.org/copyleft/.

   Each version of the License is given a distinguishing version
   number. If the Document specifies that a particular numbered
   version of this License "or any later version" applies to it,
   you have the option of following the terms and conditions
   either of that specified version or of any later version that
   has been published (not as a draft) by the Free Software
   Foundation. If the Document does not specify a version number
   of this License, you may choose any version ever published
   (not as a draft) by the Free Software Foundation.
